# ADR-020: 双方向ミドルウェアと searchRaw の導入

## コンテキスト

以前の設計ではミドルウェアはエンジンの出力（info, result）のインターセプトしか考慮されていませんでした。しかし、エンジンの入力（command）をログ出力したり、パラメータを動的に変換したりするニーズがありました。

## 決定

1. `IMiddleware` に `onCommand` メソッドを追加し、双方向のインターセプトを可能にしました。
2. アダプターから `search(options)` の責務を分離し、Facade がオプションからコマンドを生成した後に `searchRaw(command)` を呼び出すフローを基本としました。

**追記 (2026-02-11):**
`AbortSignal` による中断時、標準的な Web API (Fetch 等) の挙動に準拠し、`search()` の戻り値である Promise を `reject` することに決定しました。これにより、呼び出し側は中断を例外として処理できます。

## 結果

- 入出力全てのパイプラインをミドルウェアで完全に制御可能になりました。
- 探索開始時に前のタスクを自動停止するなどの排他制御が Facade 層で一貫して行えるようになりました。
- **追記 (2026-02-11):** 非同期ミドルウェアが混在する場合でも実行順序とデータ変換の連鎖を保証するため、並列処理を避け、`for...of` ループによるシーケンシャルな解決を徹底しました。
