# アーキテクチャと設計

このドキュメントでは、`multi-game-engines` の設計原則と技術アーキテクチャについて説明します。

## 設計原則

1.  **純粋なコア (Pure Core & Pay-as-you-go)**:
    - コアライブラリは、特定のエンジンやゲーム種別に対する知識を一切持ちません。
    - 利用者は、使用するエンジンのアダプターのみをインポートすることで、不要なコードや型定義がバンドルされるのを防ぎます。
2.  **分散型型推論 (Declaration Merging)**:
    - TypeScript の宣言併合を活用し、アダプターをインポートするだけで `bridge.getEngine('id')` の戻り値型が自動的に決定される「ゼロ構成型安全性」を実現します。
3.  **フレームワーク非依存 (Framework Agnostic)**:
    - エンジンの思考状況（検討中の指し手やスコア）は `AsyncIterable` を用いて配信されます。これにより、`for await...of` ループを用いた直感的なリアルタイム更新が可能です。
4.  **最新の Web 標準 API の活用 (2026 Ready)**:
    - **OPFS (Origin Private File System)**: 巨大な WASM や評価関数ファイルの永続化に、より高速なブラウザ内ファイルシステムを採用します（未サポート環境では IndexedDB へフォールバック）。
    - **WebAssembly (SIMD/Threads)**: エンジンの性能を最大限引き出すためのロード構成をサポートします。
    - **AbortSignal & ReadableStream**: 標準的な中断制御とデータストリーミング。

## コアコンセプト

1.  **ブリッジ (EngineBridge)**: 全てのエンジンのオーケストレーター。アダプターの登録、グローバルなイベント監視、ブリッジ全体の破棄（dispose）を担います。
2.  **ファサード (EngineFacade)**: 利用者が直接対話する統一インターフェース。内部的なアダプターの詳細を隠蔽し、ミドルウェアの適用や排他的なタスク管理を行います。
3.  **アダプターインターフェース (IEngineAdapter)**: すべての engine 実装が遵守すべき厳密に定義された契約。
4.  **エンジンローダー (EngineLoader)**: 外部リソース（WASM等）のダウンロード、SRI 検証、永続キャッシュを透過的に行うインフラ層。
5.  **ワーカーコミュニケーター (WorkerCommunicator)**: WebWorker との型安全な双方向通信を抽象化し、メッセージバッファリングによるレースコンディション防止機能を提供します。

## エンジンのロード戦略 (Loading Strategy)

リソース消費の最適化とユーザー体験の向上のため、3 つのロード戦略を提供します。

1.  **手動ロード (manual)**:
    - `engine.load()` を呼び出すまでリソースを取得しません。
    - 通信量の節約や、ライセンスへの同意後にロードを開始したい場合に最適です。
2.  **オンデマンド・フォールバック (on-demand) ※デフォルト**:
    - 通常は手動と同様ですが、ロード前に `search()` が実行されると、自動的にロードを開始し完了を待機します。
    - 開発者が初期化を意識せずに利用できる、最も利便性の高いモードです。
3.  **先行ロード (eager)**:
    - エンジンインスタンスの生成（`getEngine`）と同時にバックグラウンドでロードを開始します。
    - ユーザーが実際に操作する前に準備を完了させ、ゼロレイテンシな体験を提供します。

## プラグインシステム

誰でもプラグインを作成できるように、`@multi-game-engines/core` パッケージは `IEngineAdapter` インターフェースと `IEngine` インターフェースをエクスポートします。

### 拡張性

共通のタスク（探索、指し手、評価）のための統一インターフェースを提供しつつ、エンジン独自の機能を活用できる設計にしています。アダプターはエンジン固有のメソッドを公開でき、ユーザーはTypeScriptのジェネリクスを使用して型安全にアクセスできます。

```typescript
// エンジン固有の型を指定して型安全にアクセス
import {
  IChessSearchOptions,
  FEN,
} from "@multi-game-engines/adapter-stockfish";

const stockfish = bridge.getEngine("stockfish");
// アダプターをインポートしていれば、EngineRegistry を通じて自動的に型が推論されます
stockfish.search({ fen: "..." as FEN, depth: 20 });
```

### 多言語・多プロトコル対応

チェスの **UCI (Universal Chess Interface)**、将棋の **USI (Universal Shogi Interface)**、囲碁の **GTP (Go Text Protocol)**、オセロ・麻雀の独自プロトコル（JSON等）をサポート。それぞれのパーサーはインジェクション対策が施されており、安全に利用可能です。

## ライセンス戦略

- **コア (Core)**: MITライセンス。エンジン固有のコードを含まず、あらゆるプロジェクトで使用可能です。
- **アダプター (Adapters)**: 各アダプターは個別のnpmパッケージです。これにより、Stockfishや、ねうら王のようなGPLライセンスのエンジンをエコシステムに含めつつ、コアライブラリや利用者のアプリケーションにGPLを強制することを避けることができます。

## ライフサイクルとリソース管理

1.  **永続リスナー (Persistent Listener)**: `onInfo` 等のイベント登録は、検索タスクの切り替わりを跨いで有効 です。一度の登録で継続的な監視が可能です。

2.  **クリーンな破棄 (Clean Disposal)**: `bridge.dispose()` を呼び出すことで、登録された全エンジンの Worker を停止し、メモリとリソースを完全に解放します。

3.  **プロアクティブなメモリ管理 (Blob URL)**: `EngineLoader` は Blob URL のライフサイクルを自動追跡し、同一エンジンの再ロード時に古いリソースを明示的に `revoke` する機能（Auto-Revocation）を備えています。

4.  **セキュリティ第一 (SRI & Integrity)**: 全ての外部バイナリは SRI ハッシュ検証が必須です。改竄されたリソ ースのロードは、実行前にブロックされます。W3C 標準のマルチハッシュ形式をサポートしています。

5.  **厳格な入力検証 (Strict Input Validation)**: プロトコルレベルでのコマンドインジェクションを防ぐため、サニタイズではなく「例外スローによる拒否」を徹底しています。不正な制御文字を含む入力は、エンジンに到達する前に遮断されます（※USI/GTP/SGF で許可される記号は許可リストに明示）。

6.  **モダンな例外処理 (Error Cause API)**: ネットワークエラーや通信障害などの低レイヤーの例外は、`Error Cause API` を用いて元の例外を保持したまま `EngineError` にラップされます。加えて `remediation` フィールドにより、開発者やユーザーに対して「制御文字を除去してください」といった具体的な復旧ガイダンスを提示できます。これにより、高度なデバッグ性とユーザー体験の両立が確保されています。

7.  **WASM & バイナリリソース戦略 (WASM & Binary Strategy)**:
    - **Blob URL の制約**: セキュリティとキャッシュのために `Blob URL` を使用するため、Worker 内からの**相対パスによる追加リソース（.wasm, .nnue）のフェッチは原則禁止**です（Blob の Origin は不透明であるため）。
    - **依存性注入 (Dependency Injection)**: アダプターは、JS ローダーだけでなく WASM/NNUE バイナリも `EngineLoader` 経由で個別にロードし、その Blob URL を Worker の初期化パラメータ（`Module.wasmBinaryFile` や `postMessage`）として注入する設計を必須とします。許容されるロード経路は EngineLoader 経由で注入された URL のみです。

## UI と表現層 (UI & Presentation Layer)

本プロジェクトは、エンジンの演算結果をユーザーに届けるための、高性能かつアクセシブルな UI 構築基盤を提供します。

### 1. レイヤード・アーキテクチャ

特定のフレームワークへのロックインを避けつつ、2026 年の最新フロントエンド標準に対応するため、UI 層を以下の構成に分離しています。

1.  **Reactive Core (`ui-core`)**:
    - **役割**: フレームワーク非依存のビジネスロジック。
    - **機能**: エンジンからの高頻度な `info` ストリームの正規化（Zod によるランタイム検証）、状態管理、および `requestAnimationFrame` (RAF) を用いた描画リクエストの間引き。評価値の表示ロジック（`EvaluationPresenter`）もここに集約されています。
2.  **Localization Layer (`i18n`)**:
    - **役割**: 純粋な言語リソースの提供。
    - **機能**: JSON ベースの辞書管理と、型安全なインターフェース定義。UI 層とは疎結合に保たれます。

3.  **Framework Adapters**:
    - **`ui-react`**: React Hooks (`useSyncExternalStore`) と Context DI を活用したアダプター。Storybook 10 と Tailwind CSS v4 に完全対応。
    - **`ui-vue`**: Vue 3 Composition API (`ref`, `computed`) を活用したリアクティブ・アダプター。Storybook 10 対応済み。
    - **`ui-elements`**: Lit ベースの Web Components。あらゆる HTML 環境で動作する究極のポータビリティを提供。

### 2. 契約駆動 UI (Contract-driven UI)

UI 層に届くデータは、`ui-core` 内の Zod スキーマによって実行時に検証されます。これにより、新しいエンジンアダプターを追加した際のプロトコル不一致や、不正なメッセージによる UI のクラッシュを構造的に防ぎます。

### 3. オブザーバビリティの統合

UI 上での全ての操作（探索開始・停止等）およびエンジンの状態変化は、Core のテレメトリシステムと連動します。これにより、実環境でのユーザー体験のボトルネック（ボタンの反応速度、レンダリング遅延）を定量的・多角的に分析可能です。

### 4. 盤面表示と局面解析 (Board Rendering & Position Analysis)

エンジンの思考プロセスを視覚化するため、局面情報を解析し盤面として描画する機能を提供します。

- **局面パーサー**: FEN（チェス）や SFEN（将棋）を、描画に適した 2次元配列および持ち駒オブジェクトに変換します。このロジックは `ui-core` に実装されており、特定の描画エンジンに依存しません。

- **再利用可能なボードコンポーネント**: `ui-elements` で提供される `<chess-board>` や `<shogi-board>` は、内部で局面パーサーを利用し、CSS Grid によって効率的に再描画を行います。

- **アクセシビリティと多言語対応**: 全ての駒には `aria-label` が付与され、`pieceNames` プロパティを通じて各国語にローカライズされた駒名称を提供可能です。また、`error-message` 属性により、解析失敗時のメッセージも完全にカスタマイズ可能です。

- **アセット保護とセキュリティ (Asset Protection)**: 外部依存（Wikipedia 等）による描画崩落や SRI 検証の問題を回避するため、チェス駒などの標準アセットは **Data URI (SVG) としてソースコードに直接インライン化** されています。これにより、オフライン環境や厳格なセキュリティポリシー下でも安定した表示を保証します。

- **最適化 (Code Splitting)**: React/Vue の UI コンポーネントおよびフックは、`@multi-game-engines/ui-react/hooks` や `@multi-game-engines/ui-vue/hooks` のようなサブパス・エクスポートをサポートしており、バンドルサイズの最小化とツリーシェイキングを最適化しています。

- **リアルタイム同期**: 探索中の最善手を盤面上のハイライトとして自動反映する機能を備え、エンジン・コアの状態と UI が完全に同期した体験を提供します。

## AI 開発アーキテクチャ (AI Ensemble)

本プロジェクトのコード品質とアーキテクチャの整合性は、複数の AI ツールが相互に監視・補完し合う「AI Ensemble」体制によって維持されています。

1.  **相互レビュー・プロトコル**: 設計（Gemini） ⇔ 監査（CodeRabbit）という異なる AI モデル間の牽制により、ハルシネーションを抑制し論理的整合性を担保します。詳細は [AI相互レビューワークフロー](./AI_WORKFLOW.md) を参照してください。
2.  **多層監査ガードレール**:
    - **論理・意図**: CodeRabbit による文脈依存のレビュー。
    - **静的解析**: DeepSource による TypeScript アンチパターンとバグの自動修正。
    - **セキュリティ**: Snyk による依存関係とコードの脆弱性スキャン。
3.  **仕様の自己修復**: 実装の変更に合わせて API ドキュメントやアーキテクチャ図（Mermaid.js）を AI が自動生成し、ドキュメントの陳腐化を物理的に防ぎます。
