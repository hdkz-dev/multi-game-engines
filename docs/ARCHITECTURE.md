# アーキテクチャと設計

このドキュメントでは、`multi-game-engines` の設計原則と技術アーキテクチャについて説明します。

## 設計原則

1.  **フレームワーク非依存 (Framework Agnostic)**:
    - コアライブラリは純粋な TypeScript と標準 Web API（AsyncIterable, EventTarget 等）のみで構築します。
    - React, Vue, Angular 等の特定の UI フレームワークに依存せず、どのような環境でも動作します。
2.  **ストリーミング I/O**:
    - エンジンの思考状況（検討中の指し手やスコア）は `AsyncIterable` を用いて配信されます。これにより、`for await...of` ループを用いた直感的なリアルタイム更新が可能です。
3.  **最新の Web 標準 API の活用**:
    - **OPFS (Origin Private File System)**: 巨大な WASM や評価関数ファイルの永続化に、より高速なブラウザ内ファイルシステムを採用します（未サポート環境では IndexedDB へフォールバック）。
    - **WebAssembly (SIMD/Threads)**: エンジンの性能を最大限引き出すためのロード構成をサポートします。

## コアコンセプト
...（中略）...

1.  **ブリッジ (Core)**: エンジンのライフサイクルを管理し、統一されたAPIを提供するオーケストレーター。
2.  **アダプターインターフェース**: すべてのエンジン実装が遵守すべき厳密に定義されたインターフェース。
3.  **エンジンアダプター**: 統一されたAPIコールをエンジン固有のコマンド（チェスのUCI、将棋のUSIなど）に変換する実装レイヤー。
4.  **エンジンローダー (EngineLoader)**: 外部リソース（WASM等）のダウンロード、SRI 検証、OPFS へのキャッシュを透過的に行うインフラ層。
5.  **ワーカーコミュニケーター (WorkerCommunicator)**: WebWorker との型安全なメッセージングを抽象化する通信層。

## プラグインシステム

誰でもプラグインを作成できるように、`@multi-game-engines/core` パッケージは `IEngineAdapter` インターフェースと `IEngine` インターフェースをエクスポートします。

### 拡張性

共通のタスク（探索、指し手、評価）のための統一インターフェースを提供しつつ、エンジン独自の機能を活用できる設計にしています。アダプターはエンジン固有のメソッドを公開でき、ユーザーはTypeScriptのジェネリクスを使用して型安全にアクセスできます。

```typescript
// エンジン固有の型を指定して型安全にアクセス
const stockfish = bridge.getEngine<StockfishOptions, StockfishInfo, StockfishResult>('stockfish');
stockfish.search({ fen: '...' as FEN, depth: 20 }); // 型安全な探索
```

## ライセンス戦略

- **コア (Core)**: MITライセンス。エンジン固有のコードを含まず、あらゆるプロジェクトで使用可能です。
- **アダプター (Adapters)**: 各アダプターは個別のnpmパッケージです。これにより、StockfishのようなGPLライセンスのエンジンをエコシステムに含めつつ、コアライブラリや利用者のアプリケーションにGPLを強制することを避けることができます（そのアダプターを明示的に使用しない限り）。

## エンジンのロード戦略 (Loading Strategy)

ライセンスの隔離とユーザー体験を両立するため、エンジンのロード（WASMのダウンロード等）に関して3つの戦略を提供し、アプリ開発者が制御できるようにします。

1.  **手動ロード (Manual)**:
    - ユーザーの明示的な操作（「エンジンをインストール」ボタンなど）を待ってロードを開始します。
    - 通信量の節約や、ライセンスへの同意を求める場合に最適です。
2.  **オンデマンド・フォールバック (On-demand / Fallback)**:
    - デフォルトの設定です。基本は手動ですが、準備ができていない状態でエンジンの機能（探索など）が呼び出された場合、自動的にロードを開始します。
    - ユーザーの手間を減らしつつ、必要になるまでリソースを消費しません。
3.  **先行ロード (Eager)**:
    - アプリケーション起動後、またはアダプター登録後、即座にバックグラウンドでロードを開始します。
    - ユーザーに待ち時間を感じさせないシームレスな体験を提供します。

### ロード状況の可視化と I/O

いずれの戦略においても、アダプターは詳細な進捗状況（`ILoadProgress`）を報告します。これにより、アプリ開発者は以下のようなUIを容易に実装できます。
- インストール済みのエンジンの管理画面
- 初回ロード時のプログレスバー
- エンジン固有のライセンス同意ダイアログ

エンジンの実体（WASM等）は、Webコンテキストであれば IndexedDB や Cache Storage API を利用して永続化し、二回目以降のロードを高速化します。