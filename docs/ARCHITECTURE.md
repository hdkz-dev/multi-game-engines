# アーキテクチャと設計

このドキュメントでは、`multi-game-engines` の設計原則と技術アーキテクチャについて説明します。

## 設計原則

1.  **フレームワーク非依存 (Framework Agnostic)**:
    - コアライブラリは純粋な TypeScript と標準 Web API（AsyncIterable, EventTarget 等）のみで構築します。
    - React, Vue, Angular 等の特定の UI フレームワークに依存せず、どのような環境でも動作します。
2.  **ストリーミング I/O**:
    - エンジンの思考状況（検討中の指し手やスコア）は `AsyncIterable` を用いて配信されます。これにより、`for await...of` ループを用いた直感的なリアルタイム更新が可能です。
3.  **最新の Web 標準 API の活用 (2026 Ready)**:
    - **OPFS (Origin Private File System)**: 巨大な WASM や評価関数ファイルの永続化に、より高速なブラウザ内ファイルシステムを採用します（未サポート環境では IndexedDB へフォールバック）。
    - **WebAssembly (SIMD/Threads)**: エンジンの性能を最大限引き出すためのロード構成をサポートします。
    - **AbortSignal & ReadableStream**: 標準的な中断制御とデータストリーミング。

## コアコンセプト

1.  **ブリッジ (EngineBridge)**: 全てのエンジンのオーケストレーター。アダプターの登録、グローバルなイベント監視、ブリッジ全体の破棄（dispose）を担います。
2.  **ファサード (EngineFacade)**: 利用者が直接対話する統一インターフェース。内部的なアダプターの詳細を隠蔽し、ミドルウェアの適用や排他的なタスク管理を行います。
3.  **アダプターインターフェース (IEngineAdapter)**: すべての engine 実装が遵守すべき厳密に定義された契約。
4.  **エンジンローダー (EngineLoader)**: 外部リソース（WASM等）のダウンロード、SRI 検証、永続キャッシュを透過的に行うインフラ層。
5.  **ワーカーコミュニケーター (WorkerCommunicator)**: WebWorker との型安全な双方向通信を抽象化し、メッセージバッファリングによるレースコンディション防止機能を提供します。

## エンジンのロード戦略 (Loading Strategy)

リソース消費の最適化とユーザー体験の向上のため、3 つのロード戦略を提供します。

1.  **手動ロード (manual)**:
    - `engine.load()` を呼び出すまでリソースを取得しません。
    - 通信量の節約や、ライセンスへの同意後にロードを開始したい場合に最適です。
2.  **オンデマンド・フォールバック (on-demand) ※デフォルト**:
    - 通常は手動と同様ですが、ロード前に `search()` が実行されると、自動的にロードを開始し完了を待機します。
    - 開発者が初期化を意識せずに利用できる、最も利便性の高いモードです。
3.  **先行ロード (eager)**:
    - エンジンインスタンスの生成（`getEngine`）と同時にバックグラウンドでロードを開始します。
    - ユーザーが実際に操作する前に準備を完了させ、ゼロレイテンシな体験を提供します。

## プラグインシステム

誰でもプラグインを作成できるように、`@multi-game-engines/core` パッケージは `IEngineAdapter` インターフェースと `IEngine` インターフェースをエクスポートします。

### 拡張性

共通のタスク（探索、指し手、評価）のための統一インターフェースを提供しつつ、エンジン独自の機能を活用できる設計にしています。アダプターはエンジン固有のメソッドを公開でき、ユーザーはTypeScriptのジェネリクスを使用して型安全にアクセスできます。

```typescript
// エンジン固有の型を指定して型安全にアクセス
const stockfish = bridge.getEngine<IBaseSearchOptions, IBaseSearchInfo, IBaseSearchResult>('stockfish');
stockfish.search({ fen: '...' as FEN, depth: 20 }); // 型安全な探索
```

### 多言語・多プロトコル対応

チェスの **UCI (Universal Chess Interface)** および将棋の **USI (Universal Shogi Interface)** プロトコルをネイティブにサポート。それぞれのパーサーはインジェクション対策が施されており、安全に利用可能です。

## ライセンス戦略

- **コア (Core)**: MITライセンス。エンジン固有のコードを含まず、あらゆるプロジェクトで使用可能です。
- **アダプター (Adapters)**: 各アダプターは個別のnpmパッケージです。これにより、Stockfishや、ねうら王のようなGPLライセンスのエンジンをエコシステムに含めつつ、コアライブラリや利用者のアプリケーションにGPLを強制することを避けることができます。

## ライフサイクルとリソース管理

1.  **永続リスナー (Persistent Listener)**: `onInfo` 等のイベント登録は、検索タスクの切り替わりを跨いで有効です。一度の登録で継続的な監視が可能です。
2.  **クリーンな破棄 (Clean Disposal)**: `bridge.dispose()` を呼び出すことで、登録された全エンジンの Worker を停止し、メモリとリソースを完全に解放します。
3.  **セキュリティ第一 (SRI & Integrity)**: 全ての外部バイナリは SRI ハッシュ検証が必須です。改竄されたリソースのロードは、実行前にブロックされます。
