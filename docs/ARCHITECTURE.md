# アーキテクチャと設計

このドキュメントでは、`multi-game-engines` の設計原則と技術アーキテクチャについて説明します。

## 設計原則

1.  **純粋なコア (Pure Core & Pay-as-you-go)**:
    - コアライブラリは、特定のエンジンやゲーム種別に対する知識を一切持ちません。
    - 利用者は、使用するエンジンのアダプターのみをインポートすることで、不要なコードや型定義がバンドルされるのを防ぎます。
2.  **分散型型推論 (Declaration Merging)**:
    - TypeScript の宣言併合を活用し、アダプターをインポートするだけで `bridge.getEngine('id')` の戻り値型が自動的に決定される「ゼロ構成型安全性」を実現します。
3.  **フレームワーク非依存 (Framework Agnostic)**:
    - エンジンの思考状況（検討中の指し手やスコア）は `AsyncIterable` を用いて配信されます。これにより、`for await...of` ループを用いた直感的なリアルタイム更新が可能です。
4.  **最新の Web 標準 API の活用 (2026 Ready)**:
    - **OPFS (Origin Private File System)**: 巨大な WASM や評価関数ファイルの永続化に、より高速なブラウザ内ファイルシステムを採用します（未サポート環境では IndexedDB へフォールバック）。
    - **WebAssembly (SIMD/Threads)**: エンジンの性能を最大限引き出すためのロード構成をサポートします。
    - **AbortSignal & ReadableStream**: 標準的な中断制御とデータストリーミング。

## コアコンセプト

1.  **ブリッジ (EngineBridge)**: 全てのエンジンのオーケストレーター。アダプターの登録、グローバルなイベント監視、ブリッジ全体の破棄（dispose）を担います。
2.  **ファサード (EngineFacade)**: 利用者が直接対話する統一インターフェース。内部的なアダプターの詳細を隠蔽し、ミドルウェアの適用や排他的なタスク管理を行います。
3.  **アダプターインターフェース (IEngineAdapter)**: すべての engine 実装が遵守すべき厳密に定義された契約。
4.  **エンジンローダー (EngineLoader)**: 外部リソース（WASM等）のダウンロード、SRI 検証、永続キャッシュを透過的に行うインフラ層。
5.  **ワーカーコミュニケーター (WorkerCommunicator)**: WebWorker との型安全な双方向通信を抽象化し、メッセージバッファリングによるレースコンディション防止機能を提供します。

## エンジンのロード戦略 (Loading Strategy)

リソース消費の最適化とユーザー体験の向上のため、3 つのロード戦略を提供します。

1.  **手動ロード (manual)**:
    - `engine.load()` を呼び出すまでリソースを取得しません。
    - 通信量の節約や、ライセンスへの同意後にロードを開始したい場合に最適です。
2.  **オンデマンド・フォールバック (on-demand) ※デフォルト**:
    - 通常は手動と同様ですが、ロード前に `search()` が実行されると、自動的にロードを開始し完了を待機します。
    - 開発者が初期化を意識せずに利用できる、最も利便性の高いモードです。
3.  **先行ロード (eager)**:
    - エンジンインスタンスの生成（`getEngine`）と同時にバックグラウンドでロードを開始します。
    - ユーザーが実際に操作する前に準備を完了させ、ゼロレイテンシな体験を提供します。

## プラグインシステム

誰でもプラグインを作成できるように、`@multi-game-engines/core` パッケージは `IEngineAdapter` インターフェースと `IEngine` インターフェースをエクスポートします。

### 拡張性

共通のタスク（探索、指し手、評価）のための統一インターフェースを提供しつつ、エンジン独自の機能を活用できる設計にしています。アダプターはエンジン固有のメソッドを公開でき、ユーザーはTypeScriptのジェネリクスを使用して型安全にアクセスできます。

```typescript
// エンジン固有の型を指定して型安全にアクセス
import { IChessSearchOptions, FEN } from "@multi-game-engines/adapter-stockfish";

const stockfish = bridge.getEngine('stockfish');
// アダプターをインポートしていれば、EngineRegistry を通じて自動的に型が推論されます
stockfish.search({ fen: '...' as FEN, depth: 20 }); 
```

### 多言語・多プロトコル対応

チェスの **UCI (Universal Chess Interface)** および将棋の **USI (Universal Shogi Interface)** プロトコルをネイティブにサポート。それぞれのパーサーはインジェクション対策が施されており、安全に利用可能です。

## ライセンス戦略

- **コア (Core)**: MITライセンス。エンジン固有のコードを含まず、あらゆるプロジェクトで使用可能です。
- **アダプター (Adapters)**: 各アダプターは個別のnpmパッケージです。これにより、Stockfishや、ねうら王のようなGPLライセンスのエンジンをエコシステムに含めつつ、コアライブラリや利用者のアプリケーションにGPLを強制することを避けることができます。

## ライフサイクルとリソース管理



1.  **永続リスナー (Persistent Listener)**: `onInfo` 等のイベント登録は、検索タスクの切り替わりを跨いで有効 です。一度の登録で継続的な監視が可能です。

2.  **クリーンな破棄 (Clean Disposal)**: `bridge.dispose()` を呼び出すことで、登録された全エンジンの Worker を停止し、メモリとリソースを完全に解放します。

3.  **プロアクティブなメモリ管理 (Blob URL)**: `EngineLoader` は Blob URL のライフサイクルを自動追跡し、同一エンジンの再ロード時に古いリソースを明示的に `revoke` する機能（Auto-Revocation）を備えています。

4.  **セキュリティ第一 (SRI & Integrity)**: 全ての外部バイナリは SRI ハッシュ検証が必須です。改竄されたリソ ースのロードは、実行前にブロックされます。W3C 標準のマルチハッシュ形式をサポートしています。

5.  **厳格な入力検証 (Strict Input Validation)**: プロトコルレベルでのコマンドインジェクションを防ぐため、サニタイズではなく「例外スローによる拒否」を徹底しています。不正な制御文字を含む入力は、エンジンに到達する前に遮断されます（※USI/GTP/SGF で許可される記号は許可リストに明示）。

6.  **モダンな例外処理 (Error Cause API)**: ネットワークエラーや通信障害などの低レイヤーの例外は、`Error Cause API` を用いて元の例外を保持したまま `EngineError` にラップされます。加えて `remediation` フィールドにより、開発者やユーザーに対して「制御文字を除去してください」といった具体的な復旧ガイダンスを提示できます。これにより、高度なデバッグ性とユーザー体験の両立が確保されています。

7.  **WASM & バイナリリソース戦略 (WASM & Binary Strategy)**:
    *   **Blob URL の制約**: セキュリティとキャッシュのために `Blob URL` を使用するため、Worker 内からの**相対パスによる追加リソース（.wasm, .nnue）のフェッチは原則禁止**です（Blob の Origin は不透明であるため）。
    *   **依存性注入 (Dependency Injection)**: アダプターは、JS ローダーだけでなく WASM/NNUE バイナリも `EngineLoader` 経由で個別にロードし、その Blob URL を Worker の初期化パラメータ（`Module.wasmBinaryFile` や `postMessage`）として注入する設計を必須とします。許容されるロード経路は EngineLoader 経由で注入された URL のみです。


