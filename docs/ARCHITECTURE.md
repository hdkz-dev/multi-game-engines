# アーキテクチャと設計

このドキュメントでは、`multi-game-engines` の設計原則と技術アーキテクチャについて説明します。

## 設計原則

1. **純粋なコア (Pure Core & Pay-as-you-go)**:
   - コアライブラリは、特定のエンジンやゲーム種別に対する知識を一切持ちません。
   - **ドメイン隔離**: 特定のゲーム（チェス、将棋等）に依存するロジックや多言語リソースは、物理的に隔離されたパッケージ (`domain-chess`, `i18n-chess` 等) に分離されています。
   - 利用者は、使用するドメインのみをインポートすることで、不要なコード、型定義、アセット（駒のSVG等）、および言語データのバンドルを防ぎます。
2. **分散型型推論 (Declaration Merging)**:
   - TypeScript の宣言併合を活用し、アダプターをインポートするだけで `bridge.getEngine('id')` の戻り値型が自動的に決定される「ゼロ構成型安全性」を実現します。
3. **フレームワーク非依存 (Framework Agnostic)**:
   - エンジンの思考状況（検討中の指し手やスコア）は `AsyncIterable` を用いて配信されます。これにより、`for await...of` ループを用いた直感的なリアルタイム更新が可能です。
4. **最新の Web 標準 API の活用 (2026 Ready)**:
   - **OPFS (Origin Private File System)**: 巨大な WASM や評価関数ファイルの永続化に、より高速なブラウザ内ファイルシステムを採用します（未サポート環境では IndexedDB へフォールバック）。
   - **WebAssembly (SIMD/Threads)**: エンジンの性能を最大限引き出すためのロード構成をサポートします。
   - **AbortSignal & ReadableStream**: 標準的な中断制御とデータストリーミング。

## コアコンセプト

1. **ブリッジ (EngineBridge)**: 全てのエンジンのオーケストレーター。アダプターの登録、グローバルなイベント監視、ブリッジ全体の破棄（dispose）を担います。
2. **ファサード (EngineFacade)**: 利用者が直接対話する統一インターフェース。内部的なアダプターの詳細を隠蔽し、ミドルウェアの適用や排他的なタスク管理を行います。**ミドルウェア絶縁 (Middleware Isolation)** により、特定のミドルウェア（テレメトリ等）が故障しても、エンジン本体の探索プロセスへの影響を完全に遮断します。
3. **アダプターインターフェース (IEngineAdapter)**: すべての engine 実装が遵守すべき厳密に定義された契約。
4. **エンジンローダー (EngineLoader)**: 外部リソース（WASM等）のダウンロード、SRI 検証、永続キャッシュを透過的に行うインフラ層。受信バイト数の厳密なカウントにより、不完全なデータのキャッシュを構造的に防止します。
5. **ワーカーコミュニケーター (WorkerCommunicator)**: WebWorker との型安全な双方向通信を抽象化し、メッセージバッファリングによるレースコンディション防止機能を提供します。
6. **ネイティブ・コミュニケーター (NativeCommunicator)**: Node.js 環境での子プロセス通信を担います。**動的ストリームバッファリング**の実装により、ネットワークやパイプのパケット分割が発生しても、巨大なメッセージ（PV等）を欠落なく再構築してパースします。
7. **スコア正規化 (ScoreNormalizer)**: 将棋 (cp), チェス (cp/mate), リバーシ (diff) 等、各ゲーム固有の評価単位を `-1.0 〜 1.0` (NormalizedScore) に統一し、UI 層での汎用的な可視化を実現します。
8. **環境・リソース制御 (EnvironmentDetector & ResourceGovernor)**: `SharedArrayBuffer` の可用性、RAM、CPU コア数を動的に検知し、実行環境に最適な `Threads` や `Hash` 設定を自動的に算出・適用します。
9. **環境適応型ストレージ (Environment-Agnostic Storage)**: ブラウザの OPFS/IndexedDB に加え、Node.js/Bun 環境での OS ファイルシステムを利用した `NodeFSStorage` を備え、UI と CLI の両方で効率的なキャッシュ管理を可能にします。また、プラグイン可能なアーキテクチャにより、Cordova や Capacitor 等のネイティブファイル領域への保存ロジックも外部から注入可能です。
10. **フロー制御と中断 (Flow Control & AbortSignal)**: すべての非同期 I/O および探索プロセスで `AbortSignal` を標準採用。CLI での `Ctrl+C` や UI での画面遷移に即座に反応し、リソースを即座に解放します。
11. **Zenith Quality (Zero-Any Architecture)**: プロダクションコードにおける `any` の 100% 排除と、`exactOptionalPropertyTypes` 等の極めて厳格な TypeScript 設定に加え、**98.41% のラインカバレッジ**によって実行時の予期せぬエラーを構造的に防止します。全ての異常系（ネットワーク切断、ストレージ競合、循環参照等）はテストによって物理的に実証されています。

## エンジンのロード戦略 (Loading Strategy)

リソース消費の最適化とユーザー体験の向上のため、3 つのロード戦略を提供します。

1. **手動ロード (manual)**:
   - `engine.load()` を呼び出すまでリソースを取得しません。
   - 通信量の節約や、ライセンスへの同意後にロードを開始したい場合に最適です。
2. **オンデマンド・フォールバック (on-demand) ※デフォルト**:
   - 通常は手動と同様ですが、ロード前に `search()` が実行されると、自動的にロードを開始し完了を待機します。
   - 開発者が初期化を意識せずに利用できる、最も利便性の高いモードです。
3. **先行ロード (eager)**:
   - エンジンインスタンスの生成（`getEngine`）と同時にバックグラウンドでロードを開始します。
   - ユーザーが実際に操作する前に準備を完了させ、ゼロレイテンシな体験を提供します。

## マルチバイナリ・ディスパッチ (Binary Variant Selection)

2026 Zenith Tier 基準として、実行環境の能力（SIMD, マルチスレッド）を自動検知し、最適な WASM バイナリを選択する仕組みを備えています。

- **自動検知**: `EnvironmentDetector` がブラウザの `SharedArrayBuffer` や SIMD の支持状況を確認します。
- **バリアント優先順位**: `simd-mt` (SIMD + Multi-thread) > `simd` > `mt` > `st` (Single-thread) の順で、環境が許容する最高性能のバイナリを自動的にロードします。
- **動的フォールバック**: COOP/COEP ヘッダーが未設定の環境では、自動的にシングルスレッド版へ切り替え、クラッシュを防止します。

## 汎用フロー制御と中断 (Universal Flow Control)

UI、CLI、サーバーサイドのあらゆる環境で一貫した制御を提供します。

- **AbortSignal 標準準拠**: 全ての非同期処理（ロード、探索、バッチ解析）は `AbortSignal` を受け入れます。これにより、画面遷移や CLI でのキャンセル操作に即座に反応し、リソースを解放します。
- **環境非依存プログレス**: バイト単位の進捗通知 (`onProgress`) により、UI のプログレスバーや CLI のスピナーに進行状況を容易に反映可能です。
- **レジューム機能**: 巨大な NNUE ファイルのダウンロード失敗時、指数バックオフ付きリトライと HTTP Range による「中断箇所からの再開」を試行します。

## 巨大アセット管理 (Huge Asset Management)

100MB を超える NNUE 評価関数や定跡データを、安全かつ効率的に扱うための専用レイヤーを備えています。

- **定跡書プロバイダー (Opening Book Provider)**:
  巨大な定跡データ（`.bin`, `.db`）を、エンジン本体とは独立したアセットとして管理・共有します。`IndexedDB` 等を活用し、同一エンジンの異なるバージョン間でも定跡ファイルを効率的に再利用可能です。
- **分割検証 (Segmented Integrity)**:
  巨大ファイルをチャンク単位で分割ダウンロードし、各セグメントに対して SRI ハッシュ検証 (`Segmented SRI`) を実行します。これにより、全ダウンロード完了を待たずに改竄を検知でき、レジリエンスを高めます。

## プラグインシステム

誰でもプラグインを作成できるように、`@multi-game-engines/core` パッケージは `IEngineAdapter` インターフェースと `IEngine` インターフェースをエクスポートします。

### 拡張性

共通のタスク（探索、指し手、評価）のための統一インターフェースを提供しつつ、エンジン独自の機能を活用できる設計にしています。アダプターはエンジン固有のメソッドを公開でき、ユーザーはTypeScriptのジェネリクスを使用して型安全にアクセスできます。

```typescript
// エンジン固有の型を指定して型安全にアクセス
import {
  IChessSearchOptions,
  FEN,
} from "@multi-game-engines/adapter-stockfish";

const stockfish = bridge.getEngine("stockfish");
// アダプターをインポートしていれば、EngineRegistry を通じて自動的に型が推論されます
const fen = createFEN(
  "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
);
stockfish.search({ fen, depth: 20 });
```

### 多言語・多プロトコル対応

チェスの **UCI (Universal Chess Interface)**、将棋の **USI (Universal Shogi Interface)**、囲碁の **GTP (Go Text Protocol)**、シャンチーの **UCCI**、チャンギの **UJCI**、およびリバーシ・五目並べ・麻雀の独自プロトコル（JSON/テキスト）をサポート。それぞれのパーサーはインジェクション対策が施されており、安全に利用可能です。

### 同一ゲーム・マルチエンジン対応

本アーキテクチャは、同一のゲームに対して複数のエンジンを同時に、あるいは切り替えて実行することをネイティブにサポートしています。

- **ユニーク ID 管理**: `EngineBridge` は各アダプターを `id`（例: `chess-stockfish-16`, `chess-lc0`）で識別し、マップ管理します。これにより、バージョン違いのエンジンや、アルゴリズムの異なるエンジンの共存が可能です。
- **プロトコル再利用**: 汎用的なプロトコルアダプター（`UCIAdapter` 等）を介して、異なるバイナリ URL を指定するだけで新しいエンジンを即座に追加できます。
- **ID 空間の分離**: `chess-sf-16` と `chess-sf-17` のように ID を分けることで、同一ページ内でのエンジン比較（アンサンブル分析）を実現。
- **並列 Worker 実行**: エンジンごとに独立した Web Worker を割り当て、ブラウザのマルチコア能力を最大限活用。
- **アンサンブル・アダプター (Swarm Architecture)**: 複数のエンジンを束ね、単一の `IEngine` として振る舞わせるメタ・アダプターを提供します。単なる多数決を超えた、以下の「Swarm（群知能）」的な意思決定を可能にします。
  - **エキスパート・マッピング (Expertise Mapping)**: 各サブエンジンの「得意局面（序盤、終盤、タクティクス等）」を **Capability Vector** として数値化し、局面の動的特徴量（駒数、手番等）に基づいて動的に重み付けを調整します。
  - **合議アルゴリズム (Consensus Algorithms)**: 加重平均、多数決、または特定の局面における「専門家の優先採用」などの高度な統合ロジックを選択可能です。

- **モック・エンジン (Mock Engine for CI/CD)**:
  巨大な WASM アセットを必要とせずにプロトコルのみをエミュレートする `MockAdapter` を標準提供します。CI/CD パイプラインでの高速な自動テストや、アセット未準備状態でのフロントエンド開発に最適です。

## マルチランタイム・ハイブリッド基盤 (Multi-Runtime Hybrid)

本プロジェクトは、ウェブブラウザだけでなく Node.js や Desktop (Electron/Bun) 環境での実行もネイティブにサポートします。

1. **環境適応型ブリッジ (Hybrid Bridge)**: 実行環境を自動検知し、ブラウザでは WASM、ネイティブ環境ではローカルバイナリを透過的に切り替えます。
2. **統一インターフェース**: 実行バイナリの形態（WASM vs Native）に関わらず、利用者は同一の `IEngine` インターフェースで操作可能です。
3. **パフォーマンスの極大化**: ネイティブ環境では WASM のオーバーヘッドを避け、OS 本来の CPU 特性を最大限に引き出すバイナリを選択します。

## ライセンス戦略

- **コア (Core)**: MITライセンス。エンジン固有のコードを含まず、あらゆるプロジェクトで使用可能です。
- **アダプター (Adapters)**: 各アダプターは個別のnpmパッケージです。これにより、Stockfishや、ねうら王のようなGPLライセンスのエンジンをエコシステムに含めつつ、コアライブラリや利用者のアプリケーションにGPLを強制することを避けることができます。

## ライフサイクルとリソース管理

1. **永続リスナー (Persistent Listener)**: `onInfo` 等のイベント登録は、検索タスクの切り替わりを跨いで有効 です。一度の登録で継続的な監視が可能です。

2. **クリーンな破棄 (Clean Disposal)**: `bridge.dispose()` を呼び出すことで、登録された全エンジンの Worker を停止し、メモリとリソースを完全に解放します。

3. **プロアクティブなメモリ管理 (Blob URL)**: `EngineLoader` は Blob URL のライフサイクルを自動追跡し、同一エンジンの再ロード時に古いリソースを明示的に `revoke` する機能（Auto-Revocation）を備えています。

4. **セキュリティ第一 (SRI & Integrity)**: 全ての外部バイナリは SRI ハッシュ検証が必須です。改竄されたリソ ースのロードは、実行前にブロックされます。W3C 標準のマルチハッシュ形式をサポートしています。

5. **厳格な入力検証 (Refuse by Exception)**: プロトコルレベルでのコマンドインジェクションを防ぐため、サニタイズではなく「例外スローによる拒否」を徹底しています。不正な制御文字を含む入力は、エンジンに到達する前に遮断されます。

6. **プライバシー保護ログ (Privacy-First Logging)**: エンジンのパースエラー発生時に局面データ（FEN/SFEN等）がログに全量出力されるのを防ぐため、`truncateLog` ユーティリティにより自動的に先頭 20 文字程度に制限されます。これにより、局面データに紛れ込んだ個人情報や悪意のある入力の二次漏洩を構造的に防止します (ADR-038)。

7. **モダンな例外処理 (Error Cause API)**: ネットワークエラーや通信障害などの低レイヤーの例外は、`Error Cause API` を用いて元の例外を保持したまま `EngineError` にラップされます。加えて `remediation` や `i18nKey` フィールドにより、多言語で具体的な復旧ガイダンスを提示できます。

8. **WASM & バイナリリソース戦略 (WASM & Binary Strategy)**:
   - **Blob URL の制約**: セキュリティとキャッシュのために `Blob URL` を使用するため、Worker 内からの**相対パスによる追加リソース（.wasm, .nnue）のフェッチは原則禁止**です（Blob の Origin は不透明であるため）。
   - **依存性注入 (Dependency Injection)**: アダプターは、JS ローダーだけでなく WASM/NNUE バイナリも `EngineLoader` 経由で個別にロードし、その Blob URL を Worker の初期化パラメータ（`Module.wasmBinaryFile` や `postMessage`）として注入する設計を必須とします。許容されるロード経路は EngineLoader 経由で注入された URL のみです。

## UI と表現層 (UI & Presentation Layer)

本プロジェクトは、エンジンの演算結果をユーザーに届けるための、高性能かつアクセシブルな UI 構築基盤を提供します。

### 1. レイヤード・アーキテクチャ

特定のフレームワークへのロックインを避けつつ、2026 年の最新フロントエンド標準に対応するため、UI 層を以下の構成に分離しています。

1. **Reactive Core (`ui-core`)**:
   - **役割**: フレームワーク非依存のビジネスロジック。
   - **ディレクトリ構造**:
     - `src/state/`: 状態管理（Store）、変換ロジック（Transformer）、購読管理。
     - `src/monitor/`: 探索監視ロジック、表示用プレゼンター。
     - `src/dispatch/`: コマンド送出、ミドルウェア。
     - `src/validation/`: Zod スキーマによる通信データの実行時検証。
     - `src/i18n/`: UI 固有の多言語化基盤。
     - `src/styles/`: 全フレームワーク共有の CSS 変数・テーマ定義 (`theme.css`)。
   - **Generic State Support**:
     `SearchMonitor` と `createInitialState` は、ジェネリクスによってアプリケーション固有の状態拡張をサポートします。これにより、ベースの状態型を安全に拡張しつつ、`as unknown as` キャストを排除した 100% 型安全な開発が可能です。
2. **Localization Layer (Federated i18n)**:
   - **役割**: ドメインごとに最適化された言語リソースの提供。
   - **アーキテクチャ**: 単一の monolithic なパッケージを廃止し、物理的に分離されたサブパッケージ (`i18n-core`, `i18n-common`, `i18n-chess` 等) による「連邦型」構成を採用。
   - **Zero-Any Policy**: `DeepRecord` 型と Branded Type (`I18nKey`) により、翻訳データへのアクセスにおいて 100% の型安全性を保証。
   - **Pay-as-you-go**: 各アダプターや UI は、自身に必要な言語モジュールのみを依存関係に含めることで、バンドルサイズを極小化します。

3. **Framework Adapters (Modular Split)**:
   - **`ui-*-core`**: 各フレームワーク（React/Vue）における基盤（i18n Provider、基本的な UI コンテキスト管理）。
   - **`ui-*-monitor`**: エンジン監視・管理ツール（`EngineMonitorPanel` およびそのサブコンポーネント）。
   - **`ui-*-game`**: 個別ゲームの UI (ChessBoard 等)。
   - **`ui-react` / `ui-vue`**: 上記のモジュールを統合し、一括で提供するハブパッケージ。利用者は必要に応じて最小限の依存関係（例: `ui-chess-react` のみ）を選択可能です。
   - **`ui-elements`**: Lit ベースの Web Components。あらゆる HTML 環境で動作する究極のポータビリティを提供。

### 2. 契約駆動 UI (Contract-driven UI)

UI 層に届くデータは、`ui-core` 内の Zod スキーマによって実行時に検証されます。これにより、新しいエンジンアダプターを追加した際のプロトコル不一致や、不正なメッセージによる UI のクラッシュを構造的に防ぎます。

### 3. オブザーバビリティの統合

UI 上での全ての操作（探索開始・停止等）およびエンジンの状態変化は、Core のテレメトリシステムと連動します。これにより、実環境でのユーザー体験のボトルネック（ボタンの反応速度、レンダリング遅延）を定量的・多角的に分析可能です。

### 4. 盤面表示と局面解析 (Board Rendering & Position Analysis)

エンジンの思考プロセスを視覚化するため、局面情報を解析し盤面として描画する機能を提供します。

- **局面パーサー**: FEN（チェス）や SFEN（将棋）を、描画に適した 2次元配列および持ち駒オブジェクトに変換します。このロジックは `ui-core` に実装されており、特定の描画エンジンに依存しません。

- **コンポーネントの物理集約 (Best Practice)**: 全ての UI パッケージ（`ui-chess`, `ui-shogi`, `ui-*-monitor`）において、主要なレンダリング部品は `src/components/` フォルダに集約されています。パッケージのルートエントリポイント (`src/index.ts`) は、これらの内部コンポーネントを再エクスポートする薄い層として機能し、内部構造の変更が利用者に影響しないよう隠蔽（Encapsulation）を徹底しています。

- **再利用可能なボードコンポーネント**:
  `ui-elements` で提供される `<chess-board>` や `<shogi-board>` は、内部で局面パーサーを利用し、CSS Grid によって効率的に再描画を行います。

- **アクセシビリティと多言語対応**: 全ての駒には `aria-label` が付与され、`pieceNames` プロパティを通じて各国語にローカライズされた駒名称を提供可能です。また、`error-message` 属性により、解析失敗時のメッセージも完全にカスタマイズ可能です。

- **アセット保護とセキュリティ (Asset Protection)**: 外部依存（Wikipedia 等）による描画崩落や SRI 検証の問題を回避するため、チェス駒などの標準アセットは **Data URI (SVG) としてソースコードに直接インライン化** されています。これにより、オフライン環境や厳格なセキュリティポリシー下でも安定した表示を保証します。

- **最適化 (Code Splitting)**: React/Vue の UI コンポーネントおよびフックは、`@multi-game-engines/ui-react/hooks` や `@multi-game-engines/ui-vue/hooks` のようなサブパス・エクスポートをサポートしており、バンドルサイズの最小化とツリーシェイキングを最適化しています。

- **リアルタイム同期**: 探索中の最善手を盤面上のハイライトとして自動反映する機能を備え、エンジン・コアの状態と UI が完全に同期した体験を提供します。

### 5. ウェブ・アクセシビリティ (Web Accessibility)

2026 Zenith Tier 基準として、全ての UI コンポーネントは **WCAG 2.2 Level AA** に準拠し、スクリーンリーダーおよびキーボードのみでの操作を完全にサポートします。

- **セマンティック HTML**: `<nav>`, `<main>`, `<grid>` 等の適切なランドマークとロールを使用し、ドキュメント構造を支援技術に正確に伝えます。
- **フル・キーボードナビゲーション**: マウスで行える全ての操作（盤面の選択、指し手の詳細表示、エンジンの制御）はキーボードで実行可能です。フォーカストラップの防止と論理的なタブ順序を保証しています。
- **ARIA Live Regions**: 探索結果の更新やエラー発生など、動的な状態変化を `aria-live="polite"` 等を通じてリアルタイムに通知します。
- **コントラストと視認性**: 標準テーマにおいて十分な色コントラスト比（4.5:1 以上）を確保し、色の違いのみに依存しない情報伝達（アイコンとテキストの併用）を徹底しています。
- **自動アクセシビリティテスト**: `axe-core` を統合した Playwright テストにより、開発サイクル全体でアクセシビリティのデグレードを物理的に防止します。

## AI 開発アーキテクチャ (AI Ensemble)

本プロジェクトのコード品質とアーキテクチャの整合性は、複数の AI ツールが相互に監視・補完し合う「AI Ensemble」体制によって維持されています。

1. **相互レビュー・プロトコル**: 設計（Gemini） ⇔ 監査（CodeRabbit）という異なる AI モデル間の牽制により、ハルシネーションを抑制し論理的整合性を担保します。詳細は [AI相互レビューワークフロー](./AI_WORKFLOW.md) を参照してください。
2. **多層監査ガードレール**:
   - **論理・意図**: CodeRabbit による文脈依存のレビュー。
   - **静的解析**: DeepSource による TypeScript アンチパターンとバグの自動修正。
   - **セキュリティ**: Snyk による依存関係とコードの脆弱性スキャン。
3. **仕様の自己修復**: 実装の変更に合わせて API ドキュメントやアーキテクチャ図（Mermaid.js）を AI が自動生成し、ドキュメントの陳腐化を物理的に防ぎます。
