# AI Mutual Review Workflow (AI相互レビューワークフロー)

このドキュメントは、AIツール（Gemini CLI, CodeRabbit 等）が相互に成果物をレビューし、自律的に品質を担保するためのプロトコルを定義します。

## 🎯 目的

- **ハルシネーションの防止**: 複数のAI/視点によるクロスチェックで論理破綻を防ぐ。
- **盲点の排除**: 実装者とは異なる視点（セキュリティ、パフォーマンス等）から検証する。
- **人間への負担軽減**: 人間のレビュー前に、AI同士で可能な限りの問題を解決しておく。

---

## 🧩 Layer 0: スキル・アクティベーション (Skill Activation)

複雑なタスクや品質が要求される操作の前に、エージェントは `skills/` ディレクトリに定義された**標準化されたスキル**をアクティベート（読み込み）し、自身の能力を拡張します。

### 活用するスキルセット

- **`zenith-audit`**: 物理的な堅牢性と型安全性を極限まで高めるための深層監査。
- **`doc-sync`**: 日本語と英語のドキュメント整合性を 1:1 で維持。
- **`code-review`**: CodeRabbit 等の外部ツールを介した客観的評価。

### 運用ルール

エージェントは、以下のタイミングで自律的にスキルを適用しなければなりません。
1. **実装開始前**: `doc-sync` で最新の設計思想を同期。
2. **実装完了後**: `zenith-audit` で不安全なキャストや `any` を一掃。
3. **PR作成前**: `code-review` で最終的な品質ゲートを通過。

---

## 🔄 Layer 1: 設計・計画フェーズ (Design & Planning)

このフェーズでは、まだコードが存在しないため、Gemini 内部での**ペルソナ切り替え（Multi-Persona）**による相互レビューを行います。

### ワークフロー

1. **Architect (設計者)**: ユーザーの要望に基づき `implementation_plans/` や `TECHNICAL_SPECS.md` を作成。
2. **Reviewer (査読者)**: 作成されたドキュメントに対し、以下のコマンドで批判的レビューを実行。

### 実行コマンド

設計書や計画書を作成した後、必ず以下のプロンプトを実行して自己レビューを行うこと。

```bash
# クリティカル・レビューの実行
gemini "docs/xxx.md を読み込み、以下の観点から厳しくレビューし、修正案を提示してください：
1. アーキテクチャの整合性（既存の設計と矛盾していないか）
2. エッジケースの考慮（異常系、境界値）
3. セキュリティリスク（インジェクション、漏洩）
4. 実現可能性（現在の技術スタックで実装可能か）"
```

---

## 🛠 Layer 2: 実装・コーディングフェーズ (Implementation)

実装段階では、**Gemini (実装)** と **CodeRabbit/Snyk/qodo (監査)** の異なるツール間で相互レビューを行います。

### ワークフロー

1. **Coder (Gemini)**: コードを実装。
2. **Tester (qodo)**: 実装コードからエッジケースを網羅するテストを自動生成・補完。
3. **Security Auditor (Snyk)**: 依存関係とコードのセキュリティスキャンを実行。
4. **Reviewer (CodeRabbit)**: 客観的なコードレビュー（論理・意図）を行う。
5. **Fixer (Gemini)**: 指摘事項を修正し、再検証。

---

## 🛡 Layer 3: 統合・リリースフェーズ (Integration)

プルリクエスト作成時に、外部AIサービスによる深層チェックを行います。

### 活用ツール

- **DeepSource**: GitHub 連携により、TypeScript のアンチパターン検出と `Autofix`（自動修正提案）を実行。
- **Snyk**: 継続的な依存関係モニタリング。
- **Mermaid.js + AI**:
  - 大規模な変更時、Gemini が最新コードから **Mermaid 形式の図解** を生成。
  - `ARCHITECTURE.md` の図を更新し、視覚的な整合性を担保する。

---

## 📈 Layer 4: 戦略的分析フェーズ (Strategic Analysis)

プロジェクト全体の健康状態を長期的・俯瞰的に分析します。

### 活用ツール

- **CodeScene**:
  - 週次でリポジトリ全体の「進化」を分析。
  - ホットスポット（複雑化しているファイル）を特定。
  - **AI 負債レポート** を生成し、次スプリントのリファクタリング対象を決定。

---

## 🤖 Layer 5: エージェント・オーケストレーション (Cross-CLI)

Gemini CLI (Jules) を司令塔とし、必要に応じて他の AI CLI ツールをサブエージェントとして呼び出します。

### 連携可能なツール

- **OpenCode / Claude Code**: 特定のモデル（Claude 3.5 Sonnet 等）の特性を活かしたレビューや、特定の MCP サーバーの操作。
- **Aider**: 複雑なファイルの大量書き換えや、リポジトリ全体の高速なリファクタリング。

---

## 🆘 フォールバック・プロトコル (Graceful Degradation)

AI ツールの利用制限やエラーが発生した場合、以下の優先順位で品質を維持します。

1. **第1代替 (Tool Swap)**: 同等の能力を持つ別の AI ツールへ依頼する（例: CodeRabbit 制限時 → Claude Code へのレビュー依頼）。
2. **第2代替 (Internal Expert)**: Gemini CLI 内部の専門サブエージェント（`security-auditor` 等）を起動し、深層分析を行う。
3. **最終手段 (Local Check)**: `pnpm test` および静的解析をローカルで最大レベルまで実行し、人間に最終確認を依頼する。

---

## ✅ 品質基準 (Quality Standards)

AI相互レビュー完了とみなす基準：

1. **論理的整合性**: 設計書と実装コードに矛盾がないこと。
2. **静的解析パス**: Lint, Typecheck, Test が全て通っていること。
3. **AI監査パス**: CodeRabbit のレビューで `Critical` および `High` の指摘がゼロであること。
