_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`sri: ""` ã¨ `size: 0` ã¯ SRI æ¤œè¨¼ã‚’å®Œå…¨ã«ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹**

Stage 1 ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã—ã¦ç†è§£ã§ãã¾ã™ãŒã€ã“ã®ã¾ã¾æœ¬ç•ªãƒªãƒªãƒ¼ã‚¹ã™ã‚‹ã¨ãƒªã‚½ãƒ¼ã‚¹ã®æ•´åˆæ€§æ¤œè¨¼ãŒè¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ãƒªãƒªãƒ¼ã‚¹å‰ã«æ­£ç¢ºãª SRI ãƒãƒƒã‚·ãƒ¥ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’è¨­å®šã™ã‚‹ TODO ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚

As per coding guidelines: ã€Œã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ (SRI): å‹•çš„ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†éš›ã¯ã€å¿…ãš SRI ãƒãƒƒã‚·ãƒ¥ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ„ã¿è¾¼ã‚€ã“ã¨ã€


æœ¬ç•ªç”¨ã® SRI ãƒãƒƒã‚·ãƒ¥ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä½œæˆã‚„ã€SRI ãŒæœªè¨­å®šã®å ´åˆã«ãƒ“ãƒ«ãƒ‰æ™‚ã«è­¦å‘Šã‚’å‡ºã™ä»•çµ„ã¿ã®å°å…¥ã‚’ãŠæ‰‹ä¼ã„ã§ãã¾ã™ã€‚Issue ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿ

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 40 - 49, The
sources.main entry currently has empty sri and zero size which disables SRI;
update the sources: Record<string, IEngineSourceConfig> object by adding a clear
TODO above the main entry (or inline) stating that production must set the exact
SRI hash and file size, e.g. reference the sources constant and the main key in
stockfish.ts (IEngineSourceConfig) and replace sri: "" and size: 0 with
placeholder values plus a TODO comment; additionally, ensure build-time
validation is noted in the comment (e.g. "TODO: generate SRI & size at build and
fail/warn if unset") so reviewers know to add SRI generation/validation before
release.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**UCI åˆæœŸåŒ–ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã« `expectMessage` ã® pending ãŒæ®‹ç•™ã™ã‚‹**

`Promise.race` ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒå…ˆã« reject ã—ãŸå ´åˆã€`expectMessage` ã§ç™»éŒ²ã•ã‚ŒãŸ pending expectation ãŒã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œãšã€`pendingExpectations` ã‚»ãƒƒãƒˆã«æ®‹ã‚Šç¶šã‘ã¾ã™ã€‚å¾Œã‹ã‚‰ `"uciok"` ãŒåˆ°ç€ã™ã‚‹ã¨ã€æ—¢ã« error çŠ¶æ…‹ã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã«å¯¾ã—ã¦ä¸æ­£ãª resolve ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

<details>
<summary>â™»ï¸ AbortController ã‚’ä½¿ã£ãŸæ”¹å–„æ¡ˆ</summary>

```diff
+      const initController = new AbortController();
       await Promise.race([
         this.communicator.expectMessage<string>((data) => data === "uciok"),
-        new Promise((_, reject) => setTimeout(() => reject(new Error("UCI initialization timeout")), 10000))
+        new Promise((_, reject) => {
+          const timer = setTimeout(() => {
+            initController.abort();
+            reject(new Error("UCI initialization timeout"));
+          }, 10000);
+          initController.signal.addEventListener("abort", () => clearTimeout(timer));
+        })
       ]);
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 88 - 94, The UCI
init Promise.race can timeout but leaves the expectMessage() registration in
pendingExpectations, so pending handlers may later resolve incorrectly; update
the UCI init logic to cancel/cleanup the pending expectation when timeout occurs
â€” e.g., create an AbortController (or accept/return a cancel token) and pass its
signal to expectMessage<string>((data)=>data==="uciok", signal) or have
expectMessage return a disposer and call it in the timeout branch/finally;
ensure the pendingExpectations entry is removed (or the expectation rejects)
when the timeout fires so no stray resolver runs after the adapter is errored
(refer to expectMessage, pendingExpectations, communicator.postMessage("uci")
and the UCI initialization Promise.race).
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_âš ï¸ Potential issue_ | _ğŸ”´ Critical_

**`searchRaw` ã® `resultPromise` ã« reject ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ãªã„**

`resultPromise` ã¯ `new Promise<IBaseSearchResult>((resolve) => { ... })` ã§ç”Ÿæˆã•ã‚Œã¦ãŠã‚Šã€reject é–¢æ•°ãŒä¿æŒã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚Worker ãŒã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ãŸå ´åˆã‚„ `terminate()` ã•ã‚ŒãŸå ´åˆã€ã“ã® Promise ã¯æ°¸ä¹…ã«è§£æ±ºã•ã‚Œãšã€å‘¼ã³å‡ºã—å…ƒãŒãƒãƒ³ã‚°ã—ã¾ã™ã€‚

ã¾ãŸã€`searchRaw` ã‚’é€£ç¶šã§å‘¼ã³å‡ºã™ã¨ `this.pendingResolve` ãŒä¸Šæ›¸ãã•ã‚Œã€å‰å›ã® `resultPromise` ãŒæ°¸ä¹…ã«æœªè§£æ±ºã®ã¾ã¾æ®‹ã‚Šã¾ã™ã€‚

<details>
<summary>ğŸ› reject ãƒ‘ã‚¹ã‚’è¿½åŠ ã—ã€ç«¶åˆã‚’é˜²ãä¿®æ­£æ¡ˆ</summary>

```diff
   searchRaw(command: string | Uint8Array): ISearchTask<IBaseSearchInfo, IBaseSearchResult> {
     if (this._status !== "ready") {
-      throw new Error("Engine is not ready. Call load() first.");
+      throw new EngineError(
+        EngineErrorCode.INTERNAL_ERROR,
+        "Engine is not ready. Call load() first.",
+        this.id
+      );
+    }
+
+    // å‰å›ã®æ¢ç´¢ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯å®Œäº†ã•ã›ã‚‹
+    if (this.pendingResolve) {
+      this.infoController?.close();
+      this.infoController = null;
+      this.pendingResolve = null;
     }

     this.emitStatusChange("busy");

     // çµæœè¿”å´ç”¨ã® Promise
-    const resultPromise = new Promise<IBaseSearchResult>((resolve) => {
+    const resultPromise = new Promise<IBaseSearchResult>((resolve, reject) => {
       this.pendingResolve = resolve;
+      this.pendingReject = reject;
     });
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 125 - 169,
searchRaw currently creates resultPromise without a reject path and overwrites
this.pendingResolve on each call, causing orphaned promises; change searchRaw to
create Promise<IBaseSearchResult>((resolve, reject) => { ... }) and store both
this.pendingResolve and this.pendingReject (unique symbols to locate: searchRaw,
this.pendingResolve) then when starting a new search, if a previous
this.pendingReject exists call it with an appropriate error before overwriting
to avoid leaks; ensure any worker error/terminate handlers call
this.pendingReject and clear both pendingResolve/pendingReject after resolve or
reject so no promises remain unresolved.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**`any` ã®ä½¿ç”¨ã¯ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«é•åã—ã¦ã„ã¾ã™ã€‚**

`BaseAdapter<any, ...>` ã® `any` ã‚’ `unknown` ã¾ãŸã¯ `IBaseSearchOptions` ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ã‚ã£ã¦ã‚‚ã€ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ `any` ã®ä½¿ç”¨ã‚’ç¦æ­¢ã—ã¦ã„ã¾ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
-// eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-class MockAdapter extends BaseAdapter<any, IBaseSearchInfo, IBaseSearchResult> {
+class MockAdapter extends BaseAdapter<IBaseSearchOptions, IBaseSearchInfo, IBaseSearchResult> {
```

`IBaseSearchOptions` ã‚’ `../types` ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚
</details>

As per coding guidelines: `ç¦æ­¢: any ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« unknown ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨`

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
class MockAdapter extends BaseAdapter<IBaseSearchOptions, IBaseSearchInfo, IBaseSearchResult> {
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/__tests__/EngineBridge.test.ts` around lines 11 - 12,
Replace the forbidden use of `any` in the test adapter declaration: change the
generic on `BaseAdapter` in `class MockAdapter extends BaseAdapter<any,
IBaseSearchInfo, IBaseSearchResult>` to a safe type (either `unknown` with
guards or the bounded generic `IBaseSearchOptions`) and import
`IBaseSearchOptions` from `../types`; update the class signature to use
`IBaseSearchOptions` (or `unknown`) and ensure any places that relied on `any`
are adjusted to satisfy the stricter type (add minimal type guards or casts in
the test if necessary).
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**`as any` ã®ä»£ã‚ã‚Šã«ãƒ–ãƒ©ãƒ³ãƒ‰å‹ `FEN` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„**

ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ `any` ã®ä½¿ç”¨ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ã‚‚ `FEN` ãƒ–ãƒ©ãƒ³ãƒ‰å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€å‹ã®ä¸€è²«æ€§ãŒä¿ãŸã‚Œã¾ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
+import { FEN } from "../types";
 // ...
 const options = {
-  // eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-  fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" as any,
+  fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" as FEN,
   depth: 15,
   time: 1000,
 };
```
</details>

As per coding guidelines: "ç¦æ­¢: `any` ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« `unknown` ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨" ãŠã‚ˆã³ "Branded Types ã®å¾¹åº•: `FEN`, `Move` ç­‰ã®ãƒ‰ãƒ¡ã‚¤ãƒ³å›ºæœ‰å‹ã‚’ `string` ã¨æ··ç”¨ã—ãªã„ã“ã¨"

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/__tests__/UCIParser.test.ts` around lines 36 - 38, Replace
the prohibited "as any" on the fen property with the branded FEN type: import
the FEN brand type and change the test value to be typed as FEN (e.g., assign
the string to a variable typed FEN or cast to FEN) so the fen field uses the
domain-specific brand instead of any; update the test's fen usage accordingly
(refer to the fen property and the FEN brand type).
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commit 7b7f348
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å†ç™»éŒ²æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­ãŒãƒªãƒ¼ã‚¯ã™ã‚‹**

`registerAdapter()` ã¯æ¯å› `adapter.onStatusChange()`, `adapter.onProgress()`, `adapter.onTelemetry()` ã‚’å‘¼ã³å‡ºã—ã¾ã™ãŒã€è¿”å´ã•ã‚Œã‚‹ unsubscribe é–¢æ•°ã‚’ä¿æŒã—ã¦ã„ã¾ã›ã‚“ã€‚åŒã˜ ID ã§å†ç™»éŒ²ã—ãŸå ´åˆã€æ—§ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®è³¼èª­ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªã‚¹ãƒŠãƒ¼ã¸ã®ä¼æ’­ã‚’ç¶šã‘ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã¨é‡è¤‡ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ã®åŸå› ã«ãªã‚Šã¾ã™ã€‚

<details>
<summary>ğŸ› unsubscribe é–¢æ•°ã‚’ä¿æŒã—ã€å†ç™»éŒ²æ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ææ¡ˆ</summary>

```diff
+  private adapterUnsubscribers = new Map<string, (() => void)[]>();
+
   registerAdapter<
     T_OPTIONS extends IBaseSearchOptions,
     T_INFO extends IBaseSearchInfo,
     T_RESULT extends IBaseSearchResult,
   >(adapter: IEngineAdapter<T_OPTIONS, T_INFO, T_RESULT>): void {
     if (this.adapters.has(adapter.id)) {
       console.warn(`Adapter with ID "${adapter.id}" is already registered. Overwriting.`);
+      // æ—§ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®è³¼èª­ã‚’è§£é™¤
+      this.adapterUnsubscribers.get(adapter.id)?.forEach(unsub => unsub());
     }
 
-    adapter.onStatusChange((status) => {
+    const unsubs: (() => void)[] = [];
+    unsubs.push(adapter.onStatusChange((status) => {
       this.statusListeners.forEach(cb => cb(adapter.id, status));
-    });
-    adapter.onProgress((progress) => {
+    }));
+    unsubs.push(adapter.onProgress((progress) => {
       this.progressListeners.forEach(cb => cb(adapter.id, progress));
-    });
+    }));
     adapter.onTelemetry?.((event) => {
       this.telemetryListeners.forEach(cb => cb(adapter.id, event));
     });
+    this.adapterUnsubscribers.set(adapter.id, unsubs);
 
     this.adapters.set(adapter.id, adapter);
   }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineBridge.ts` around lines 82 - 98, The
registerAdapter logic currently calls adapter.onStatusChange, adapter.onProgress
and adapter.onTelemetry without retaining unsubscribe callbacks, causing leaks
and duplicate events when an adapter with the same id is re-registered; modify
registerAdapter to store the unsubscribe functions (e.g., in a new Map keyed by
adapter.id) for each subscription returned by
onStatusChange/onProgress/onTelemetry (handle optional onTelemetry with ?.), and
when an adapter with that id already exists call and clear those stored
unsubscribers before attaching new listeners (also ensure unsubscribers are
called when removing adapters); update references to adapters, statusListeners,
progressListeners and telemetryListeners accordingly.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`getEngine()` ãŒå‘¼ã³å‡ºã—ã”ã¨ã«æ–°ã—ã„ `EngineFacade` ã‚’ç”Ÿæˆã™ã‚‹**

åŒã˜ ID ã«å¯¾ã—ã¦ `getEngine()` ã‚’è¤‡æ•°å›å‘¼ã¶ã¨ã€ç‹¬ç«‹ã—ãŸ `activeTask` çŠ¶æ…‹ã‚’æŒã¤åˆ¥ã€…ã® Facade ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¿”ã•ã‚Œã¾ã™ã€‚ä¸€æ–¹ã® Facade ã§é–‹å§‹ã—ãŸæ¢ç´¢ãŒã€ä»–æ–¹ã® Facade ã‹ã‚‰ã¯èªè­˜ã•ã‚Œãšã€æ’ä»–åˆ¶å¾¡ï¼ˆauto-abortï¼‰ãŒæ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚

ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã‹ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã€Œå‘¼ã³å‡ºã—ã”ã¨ã«æ–°è¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¿”ã‚‹ã€æ—¨ã‚’æ˜è¨˜ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineBridge.ts` around lines 105 - 122, getEngine
currently constructs a new EngineFacade on each call so multiple calls for the
same id produce independent facades (separate activeTask state) which breaks
cross-facade coordination (auto-abort). Fix by caching EngineFacade instances
inside EngineBridge: add a facades Map keyed by id, return the cached
EngineFacade if present, and only create+store a new EngineFacade (using
adapter, sortedMiddlewares, this) when none exists; ensure you invalidate or
update the cached facade when adapters or middlewares change. Reference symbols:
getEngine, EngineFacade, activeTask, adapters, middlewares on EngineBridge.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`signal` ãŒæ—¢ã« abort æ¸ˆã¿ã®å ´åˆã€`abort` ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã—ãªã„**

`options.signal` ãŒ `search()` å‘¼ã³å‡ºã—æ™‚ç‚¹ã§æ—¢ã« `aborted` çŠ¶æ…‹ã®å ´åˆã€`abort` ã‚¤ãƒ™ãƒ³ãƒˆã¯ã‚‚ã† dispatch ã•ã‚Œãªã„ãŸã‚ã€`addEventListener` ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚äº‹å‰ã« `signal.aborted` ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

<details>
<summary>ğŸ› ä¿®æ­£æ¡ˆ</summary>

```diff
     // 4. AbortSignal ã¨ã®é€£å‹•
     if (options.signal) {
+      if (options.signal.aborted) {
+        void task.stop();
+      } else {
         options.signal.addEventListener("abort", () => {
           void task.stop();
         }, { once: true });
+      }
     }
```
</details>

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    if (options.signal) {
      if (options.signal.aborted) {
        void task.stop();
      } else {
        options.signal.addEventListener("abort", () => {
          void task.stop();
        }, { once: true });
      }
    }
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineFacade.ts` around lines 94 - 98, If
options.signal may already be aborted when search() is called, check
options.signal.aborted before adding the event listener and call task.stop()
immediately in that case; keep the existing addEventListener(...) with { once:
true } for future aborts. Concretely, before
options.signal.addEventListener(...) inspect options.signal.aborted and invoke
task.stop() if true, otherwise attach the listener that calls task.stop()
(referencing options.signal, addEventListener, and task.stop).
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**SRI ãŒç©ºæ–‡å­—åˆ—ã®å ´åˆã€æ•´åˆæ€§æ¤œè¨¼ãŒå®Œå…¨ã«ãƒã‚¤ãƒ‘ã‚¹ã•ã‚Œã‚‹**

`config.sri` ãŒç©ºæ–‡å­—åˆ— `""` ã®å ´åˆã€falsy ã¨è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ SRI ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯ãŒã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã€ã•ã‚‰ã« `SecurityAdvisor.getSafeFetchOptions("")` ã‚‚ `integrity` ãªã—ã® `{}` ã‚’è¿”ã—ã¾ã™ã€‚çµæœã¨ã—ã¦ã€SRI æ¤œè¨¼ãªã—ã§ãƒªã‚½ãƒ¼ã‚¹ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¾ã™ã€‚

`IEngineSourceConfig.sri` ã¯å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`readonly sri: string`ï¼‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ç©ºæ–‡å­—åˆ—ã‚’è¨±å®¹ã™ã‚‹ã®ã¯è¨­è¨ˆæ„å›³ã¨çŸ›ç›¾ã—ã¾ã™ã€‚å®Ÿéš›ã« `StockfishAdapter` ã® `sources.main.sri` ã¯ `""` ã«è¨­å®šã•ã‚Œã¦ãŠã‚Šã€ã“ã®ãƒ‘ã‚¹ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ã€Œå‹•çš„ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†éš›ã¯ã€å¿…ãš SRI ãƒãƒƒã‚·ãƒ¥ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ„ã¿è¾¼ã‚€ã“ã¨ã€ã¨å®šã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

<details>
<summary>ğŸ”’ ææ¡ˆ: SRI ãŒæœªè¨­å®šã®å ´åˆã¯æ˜ç¤ºçš„ã«ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯è­¦å‘Šã‚’å‡ºã™</summary>

```diff
   async loadResource(engineId: string, config: IEngineSourceConfig): Promise<string> {
     // 1. SRI ã®å½¢å¼ãƒã‚§ãƒƒã‚¯ (Fail-fast)
-    if (config.sri && !SecurityAdvisor.isValidSRI(config.sri)) {
+    if (!config.sri) {
+      console.warn(`[EngineLoader] No SRI hash provided for engine "${engineId}". Resource integrity cannot be verified.`);
+    } else if (!SecurityAdvisor.isValidSRI(config.sri)) {
       throw new EngineError(
         EngineErrorCode.SRI_MISMATCH,
         `Invalid SRI hash format: ${config.sri}`,
         engineId
       );
     }
```
</details>

As per coding guidelines: ã€Œã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ (SRI): å‹•çš„ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†éš›ã¯ã€å¿…ãš SRI ãƒãƒƒã‚·ãƒ¥ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ„ã¿è¾¼ã‚€ã“ã¨ã€

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
  async loadResource(engineId: string, config: IEngineSourceConfig): Promise<string> {
    // 1. SRI ã®å½¢å¼ãƒã‚§ãƒƒã‚¯ (Fail-fast)
    if (!config.sri) {
      console.warn(`[EngineLoader] No SRI hash provided for engine "${engineId}". Resource integrity cannot be verified.`);
    } else if (!SecurityAdvisor.isValidSRI(config.sri)) {
      throw new EngineError(
        EngineErrorCode.SRI_MISMATCH,
        `Invalid SRI hash format: ${config.sri}`,
        engineId
      );
    }
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineLoader.ts` around lines 23 - 31, loadResource
ã® SRI ãƒã‚§ãƒƒã‚¯ã¯ falsy åˆ¤å®šã®ãŸã‚ç©ºæ–‡å­—åˆ— "" ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã—ã¾ã„ SRI
æ¤œè¨¼ãŒãƒã‚¤ãƒ‘ã‚¹ã•ã‚Œã‚‹ãŸã‚ã€IEngineSourceConfig.sri ãŒç©ºæ–‡å­—åˆ—ã®å ´åˆã‚’æ˜ç¤ºçš„ã«ä¸æ­£æ‰±ã„ã«ã—ã¦å¤±æ•—ã•ã›ã¦ãã ã•ã„; å…·ä½“çš„ã«ã¯
EngineLoader.ts ã® loadResource å†…ã®æ¡ä»¶ã‚’å˜ãªã‚‹ `if (config.sri && ...)`
ã‹ã‚‰ç©ºæ–‡å­—åˆ—ã‚‚æ¤œå‡ºã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«å¤‰æ›´ã—ã€ç©ºã¾ãŸã¯æœªè¨­å®šã® SRI ã®ã¨ãã¯ EngineError(EngineErrorCode.SRI_MISMATCH,
...) ã‚’æŠ•ã’ã—ã¦å‡¦ç†ã‚’ä¸­æ–­ã—ã€ã¾ãŸ SecurityAdvisor.getSafeFetchOptions ã‚’å‘¼ã¶å‰ã« config.sri
ãŒæœ‰åŠ¹ãªãƒãƒƒã‚·ãƒ¥ã§ã‚ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ï¼ˆå‚ç…§ã‚·ãƒ³ãƒœãƒ«: loadResource, IEngineSourceConfig.sri,
SecurityAdvisor.getSafeFetchOptions, EngineError, EngineErrorCodeï¼‰ã€‚
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³é•å: `any` ã®ä½¿ç”¨ãŒç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚**

`globalThis as any` ã¯ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã®ã€Œç¦æ­¢: `any` ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« `unknown` ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã€ã«æŠµè§¦ã—ã¾ã™ã€‚ESLint ã®æŠ‘åˆ¶ã‚³ãƒ¡ãƒ³ãƒˆã§æ„å›³ã¯èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ« API ã‚¢ã‚¯ã‚»ã‚¹ã«å¿…è¦ãªæœ€å°é™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ `any` ã‚’å›é¿ã§ãã¾ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
+/** ç’°å¢ƒæ¤œå‡ºã«å¿…è¦ãªã‚°ãƒ­ãƒ¼ãƒãƒ« API ã®æœ€å°å‹å®šç¾© */
+interface GlobalEnv {
+  navigator?: {
+    storage?: { getDirectory?: unknown };
+    ml?: unknown;
+    gpu?: unknown;
+  };
+  SharedArrayBuffer?: unknown;
+  WebTransport?: unknown;
+}
+
 export class CapabilityDetector {
   static async detect(): Promise<ICapabilities> {
     const details: Record<string, string> = {};
-    // eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-    const g = globalThis as any;
+    const g = globalThis as unknown as GlobalEnv;
```
</details>

As per coding guidelines: "ç¦æ­¢: `any` ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« `unknown` ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨"

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/capabilities/CapabilityDetector.ts` around lines 17 - 18,
ã“ã®è¡Œã§ä½¿ã£ã¦ã„ã‚‹ `globalThis as any` ã‚’ç¦æ­¢ã•ã‚ŒãŸ `any` ã‚’ä½¿ã‚ãªã„å½¢ã«ç½®ãæ›ãˆã¦ãã ã•ã„: å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«å†…ã«å¿…è¦ãªã‚°ãƒ­ãƒ¼ãƒãƒ«
API ã ã‘ã‚’å«ã‚€å°ã•ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆä¾‹: CapabilityDetector ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰/ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ç¾¤ï¼‰ã‚’ä½œã‚Šã€`g`
ã‚’ãã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å‹ï¼ˆã¾ãŸã¯ `unknown` ã‚’ä½¿ã£ã¦ã‹ã‚‰å‹ã‚¬ãƒ¼ãƒ‰ã§æ¤œè¨¼ï¼‰ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¦ã‹ã‚‰ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã—ã¦ãã ã•ã„; å¯¾è±¡ã‚·ãƒ³ãƒœãƒ«ã¯å¤‰æ•° `g`
ã¨ãƒ•ã‚¡ã‚¤ãƒ«å†…ã® CapabilityDetector å‘¨è¾ºã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å‚ç…§ã§ã™ã€‚
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«å¾“ã„ã€`any` ã®ä½¿ç”¨ã‚’é¿ã‘ã¦ãã ã•ã„ã€‚**

`captureStackTrace` ã¯ V8 å›ºæœ‰ã® API ã§ã‚ã‚Šã€æ¨™æº–ã® `Error` å‹å®šç¾©ã«å«ã¾ã‚Œãªã„ã“ã¨ã¯ç†è§£ã§ãã¾ã™ãŒã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ `any` ã®ä½¿ç”¨ãŒç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚å‹å®‰å…¨ãªä»£æ›¿æ¡ˆã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
-    // eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-    if ((Error as any).captureStackTrace) {
-      // eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-      (Error as any).captureStackTrace(this, EngineError);
-    }
+    const ErrorWithCapture = Error as unknown as {
+      captureStackTrace?: (target: object, constructor: NewableFunction) => void;
+    };
+    if (ErrorWithCapture.captureStackTrace) {
+      ErrorWithCapture.captureStackTrace(this, EngineError);
+    }
```
</details>

As per coding guidelines: ã€Œç¦æ­¢: `any` ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« `unknown` ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã€

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
     */
    const ErrorWithCapture = Error as unknown as {
      captureStackTrace?: (target: object, constructor: NewableFunction) => void;
    };
    if (ErrorWithCapture.captureStackTrace) {
      ErrorWithCapture.captureStackTrace(this, EngineError);
    }
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/errors/EngineError.ts` around lines 19 - 24, Replace the
unsafe "any" casts around captureStackTrace by declaring a small V8-specific
type and casting Error through unknown to that interface, then use optional
chaining to call captureStackTrace; specifically, create an interface (e.g.
V8ErrorConstructor with captureStackTrace?: (target: Function, ctor?: Function)
=> void), cast Error as unknown as V8ErrorConstructor, and invoke
v8Error.captureStackTrace?.(this, EngineError) instead of using (Error as
any).captureStackTrace and (Error as any).captureStackTrace(this, EngineError);
this removes any while keeping type safety around EngineError and
captureStackTrace usage.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

<details>
<summary>ğŸ§© Analysis chain</summary>

ğŸ Script executed:

```shell
#!/bin/bash
# Verify what each sub-module index.ts exports
echo "=== adapters/index.ts ==="
if [ -f packages/core/src/adapters/index.ts ]; then
  cat packages/core/src/adapters/index.ts
else
  echo "File not found"
fi
echo ""
echo "=== workers/index.ts ==="
if [ -f packages/core/src/workers/index.ts ]; then
  cat packages/core/src/workers/index.ts
else
  echo "File not found"
fi
echo ""
echo "=== bridge/index.ts ==="
if [ -f packages/core/src/bridge/index.ts ]; then
  cat packages/core/src/bridge/index.ts
else
  echo "File not found"
fi
echo ""
echo "=== storage/index.ts ==="
if [ -f packages/core/src/storage/index.ts ]; then
  cat packages/core/src/storage/index.ts
else
  echo "File not found"
fi
echo ""
echo "=== types/index.ts (or types.ts) ==="
if [ -f packages/core/src/types/index.ts ]; then
  cat packages/core/src/types/index.ts
elif [ -f packages/core/src/types.ts ]; then
  cat packages/core/src/types.ts
else
  echo "File not found"
fi
```

Repository: hdkz-dev/multi-game-engines

Length of output: 13070

---



</details>

**Facade ãƒ‘ã‚¿ãƒ¼ãƒ³é•åï¼šå†…éƒ¨å®Ÿè£…ã‚¯ãƒ©ã‚¹ãŒå…¬é–‹ API ã‚µãƒ¼ãƒ•ã‚§ã‚¹ã«éœ²å‡ºã—ã¦ã„ã¾ã™ã€‚**

æ¤œæŸ»çµæœã‹ã‚‰ã€ä»¥ä¸‹ã®å†…éƒ¨å®Ÿè£…ã‚¯ãƒ©ã‚¹ãŒæ¶ˆè²»è€…ã«ç›´æ¥å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ï¼š

- `adapters/index.ts`: `BaseAdapter`ï¼ˆé©ç”¨ä¸å¯ï¼‰
- `workers/index.ts`: `WorkerCommunicator`ï¼ˆé©ç”¨ä¸å¯ï¼‰
- `bridge/index.ts`: `EngineBridge`ã€`EngineFacade`ã€`EngineLoader`ï¼ˆå…·è±¡å®Ÿè£…ï¼‰
- `storage/index.ts`: `OPFSStorage`ã€`IndexedDBStorage`ï¼ˆå…·è±¡å®Ÿè£…ï¼‰

ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ã€æ¶ˆè²»è€…ã¯ `IEngine` ã®ã¿ã‚’ä»‹ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆ©ç”¨ã—ã€`IEngineAdapter` ãªã©ã®å†…éƒ¨å®Ÿè£…ã¯éš è”½ã™ã¹ãã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ç¾åœ¨ã® `export *` ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ã€ã“ã‚Œã‚‰ã®å®Ÿè£…è©³ç´°ãŒ `packages/core/src/index.ts` ã‚’é€šã˜ã¦å…¬é–‹ã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚

**å¯¾ç­–ï¼š** å„ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® `index.ts` ã§å…¬é–‹å¯¾è±¡ã‚’æ˜ç¤ºçš„ã«åˆ¶é™ã—ã¦ãã ã•ã„ã€‚æ¶ˆè²»è€…å‘ã‘ã«ã¯å¯¾å¿œã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆä¾‹ï¼š`IEngineAdapter`ï¼‰ã®ã¿ã‚’ã€å¿…è¦ã«å¿œã˜ã¦å·¥å ´é–¢æ•°ã‚’é€šã˜ã¦æä¾›ã—ã€å…·è±¡ã‚¯ãƒ©ã‚¹ã¯å†…éƒ¨ã«ç•™ã‚ã¦ãã ã•ã„ã€‚

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/index.ts` around lines 1 - 8, The root export file is
re-exporting concrete internal classes (BaseAdapter, WorkerCommunicator,
EngineBridge, EngineFacade, EngineLoader, OPFSStorage, IndexedDBStorage) which
exposes implementation details; update the submodule index files to export only
the public interfaces and factory creators (e.g., export IEngine,
IEngineAdapter, and any createXFactory functions) and remove exports of the
concrete classes, then update the central exports in packages/core/src/index.ts
to only re-export those interfaces and factories (not the concrete symbols) so
consumers see IEngine and IEngineAdapter-only surface; ensure any code that
needs the concrete classes remains internal to the module or accessed via
factory functions.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`createSearchCommand` ãŒ `position` ã¨ `go` ã‚’æ”¹è¡Œã§çµåˆã—ãŸå˜ä¸€æ–‡å­—åˆ—ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚**

UCI ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã¯ `position fen ...` ã¨ `go ...` ã¯åˆ¥ã€…ã®ã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦é€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å˜ä¸€æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ãŸå ´åˆã€å‘¼ã³å‡ºã—å…ƒãŒæ”¹è¡Œã§åˆ†å‰²ã—ã¦é€ä¿¡ã—ãªã‘ã‚Œã°ã‚¨ãƒ³ã‚¸ãƒ³ãŒæ­£ã—ãè§£é‡ˆã§ãã¾ã›ã‚“ã€‚

ã‚³ãƒãƒ³ãƒ‰ã‚’é…åˆ—ã§è¿”ã™ã‹ã€å‘¼ã³å‡ºã—å…ƒã§åˆ†å‰²ã™ã‚‹è¦ç´„ã‚’æ˜ç¤ºã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆï¼ˆé…åˆ—ã‚’è¿”ã™å ´åˆï¼‰</summary>

ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ `IProtocolParser.createSearchCommand` ã®æˆ»ã‚Šå€¤å‹ã®å¤‰æ›´ãŒå¿…è¦ã«ãªã‚Šã¾ã™ãŒã€ã‚ˆã‚Šå®‰å…¨ãªè¨­è¨ˆã§ã™ï¼š

```diff
-  createSearchCommand(options: IBaseSearchOptions): string {
-    let cmd = `position fen ${options.fen}
-go`;
-    if (options.depth) cmd += ` depth ${options.depth}`;
-    if (options.time) cmd += ` movetime ${options.time}`;
-    if (options.nodes) cmd += ` nodes ${options.nodes}`;
-    return cmd;
+  createSearchCommand(options: IBaseSearchOptions): string[] {
+    const position = `position fen ${options.fen}`;
+    let go = "go";
+    if (options.depth) go += ` depth ${options.depth}`;
+    if (options.time) go += ` movetime ${options.time}`;
+    if (options.nodes) go += ` nodes ${options.nodes}`;
+    return [position, go];
   }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/protocols/UCIParser.ts` around lines 79 - 86, The
createSearchCommand currently concatenates "position fen ..." and "go ..." into
one newline-separated string; change it to return an array of individual UCI
commands (e.g., ["position fen ...", "go ..."]) so each command is sent
separately: update the createSearchCommand signature in IProtocolParser to
return string[] (or an agreed tuple) and modify createSearchCommand (referenced
by name and using IBaseSearchOptions) to build a first element "position fen
{options.fen}" and a second element "go" with depth/movetime/nodes appended to
that second string; also update all callers to accept and send each array
element as a separate UCI command.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
![critical](https://www.gstatic.com/codereviewagent/critical.svg)

`engine.search()` ã¯ `Promise<ISearchTask>` ã‚’è¿”ã™éåŒæœŸé–¢æ•°ã§ã™ãŒã€`await` ãŒæŠœã‘ã¦ã„ã¾ã™ã€‚
ã“ã®ãŸã‚ã€`currentTask` å¤‰æ•°ã«ã¯ `ISearchTask` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã `Promise` ãŒä»£å…¥ã•ã‚Œã¦ã—ã¾ã„ã€å¾Œç¶šã® `currentTask.info` ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã§å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚

```suggestion
            currentTask = await engine.search({
                fen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
                depth: 15
            });
```
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`set()` ã§ `writable.write()` ãŒå¤±æ•—ã—ãŸå ´åˆã€`WritableStream` ãŒãƒªãƒ¼ã‚¯ã™ã‚‹**

`write()` ã§ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹ã¨ `close()` ãŒå‘¼ã°ã‚Œãšã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ãŒãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã¾ã¾ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`try/finally` ã§ `close()` ã‚’ä¿è¨¼ã—ã¦ãã ã•ã„ã€‚

<details>
<summary>ğŸ› ä¿®æ­£æ¡ˆ</summary>

```diff
   async set(key: string, data: ArrayBuffer | Blob): Promise<void> {
     const root = await this.getRoot();
     const fileHandle = await root.getFileHandle(key, { create: true });
     const writable = await fileHandle.createWritable();
-    await writable.write(data);
-    await writable.close();
+    try {
+      await writable.write(data);
+    } finally {
+      await writable.close();
+    }
   }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/storage/OPFSStorage.ts` around lines 17 - 23, In set(),
ensure the FileSystemWritableFileStream returned by fileHandle.createWritable()
is always finalized: wrap the write/close in try/catch and on error call
writable.abort() (and rethrow) so the stream/file lock is released; reference
the set method, the writable variable and
fileHandle.getFileHandle/createWritableâ€”replace the current await
writable.write(data); await writable.close(); with a try { await
writable.write(data); await writable.close(); } catch (err) { await
writable.abort().catch(()=>{}); throw err; } to guarantee no leaked writable
stream.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commits 688c607 to bd47e24
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`onGlobalStatusChange` / `onGlobalTelemetry` ãŒè³¼èª­è§£é™¤é–¢æ•°ã‚’è¿”ã•ãªã„è¨­è¨ˆã¯ã€ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ¬ãƒ™ãƒ«ã®è³¼èª­ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ä¸æ•´åˆã§ã™ã€‚**

`IEngineAdapter` ã® `onStatusChange`ï¼ˆLine 378ï¼‰ã€`onProgress`ï¼ˆLine 380ï¼‰ã€`onTelemetry`ï¼ˆLine 382ï¼‰ã¯ã™ã¹ã¦ `() => void` ã‚’è¿”ã—ã¦ã‚¢ãƒ³ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ã‚’å¯èƒ½ã«ã—ã¦ã„ã¾ã™ãŒã€`IEngineBridge` ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«è³¼èª­ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯è¿”ã‚Šå€¤ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ¶ˆè²»å´ã§è³¼èª­è§£é™¤ãŒã§ããšã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®åŸå› ã«ãªã‚Šå¾—ã¾ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–ã‚’ä¸­å¤®ã§è³¼èª­ã—ã¾ã™ (2026 Best Practice) */
- onGlobalStatusChange?(callback: (id: string, status: EngineStatus) => void): void;
+ onGlobalStatusChange?(callback: (id: string, status: EngineStatus) => void): () => void;
  /** ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚’ä¸€æ‹¬ã§è³¼èª­ã—ã¾ã™ (2026 Best Practice) */
- onGlobalTelemetry?(callback: (id: string, event: ITelemetryEvent) => void): void;
+ onGlobalTelemetry?(callback: (id: string, event: ITelemetryEvent) => void): () => void;
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/types.ts` around lines 451 - 454, The global subscription
methods onGlobalStatusChange and onGlobalTelemetry currently donâ€™t return
unsubscribe functions, causing inconsistency with
IEngineAdapter.onStatusChange/onProgress/onTelemetry which return () => void;
change the signatures in IEngineBridge (or the containing type) so both
onGlobalStatusChange(callback: (id: string, status: EngineStatus) => void) and
onGlobalTelemetry(callback: (id: string, event: ITelemetryEvent) => void) return
a () => void unsubscribe function, and update any implementations to return a
closure that removes the listener when invoked.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸ”´ Critical_

**`terminate()` ãŒå¾…æ©Ÿä¸­ã® `expectMessage` Promise ã‚’ reject ã›ãšã«ã‚¯ãƒªã‚¢ã—ã¦ã„ã‚‹**

`pendingExpectations.clear()` ã¯ Promise ã‚’ reject ã›ãšã«ç ´æ£„ã™ã‚‹ãŸã‚ã€`expectMessage()` ã‚’ `await` ã—ã¦ã„ã‚‹å‘¼ã³å‡ºã—å…ƒãŒæ°¸ä¹…ã«ãƒãƒ³ã‚°ã—ã¾ã™ã€‚`onerror` ãƒãƒ³ãƒ‰ãƒ©ã§ã¯æ­£ã—ãå…¨ä»¶ reject ã—ã¦ã„ã‚‹ã®ã«ã€`terminate()` ã§ã¯è¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

<details>
<summary>ğŸ› terminate æ™‚ã« pending ã‚’ reject ã™ã‚‹ä¿®æ­£æ¡ˆ</summary>

```diff
   terminate(): void {
     if (this.worker) {
       this.worker.terminate();
       this.worker = null;
     }
     this.messageListeners.clear();
+    const terminationError = new EngineError(
+      EngineErrorCode.INTERNAL_ERROR,
+      "Worker was terminated."
+    );
+    this.pendingExpectations.forEach((exp) => exp.reject(terminationError));
     this.pendingExpectations.clear();
   }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/workers/WorkerCommunicator.ts` around lines 105 - 112,
terminate() currently clears pendingExpectations without rejecting their
Promises, causing any callers awaiting expectMessage() to hang; update
terminate() (in WorkerCommunicator) to iterate over this.pendingExpectations and
call reject(new Error('Worker terminated')) for each pending entry (matching how
onerror rejects expectations), then clear() the map and proceed to terminate the
worker and clear messageListeners; ensure you reference the expectMessage()
contract so the rejection message is meaningful and avoid double-rejecting by
checking if an entry has an associated reject function before invoking it.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commit 688c607
![security-medium](https://www.gstatic.com/codereviewagent/security-medium-priority.svg) ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The `sri` property is set to an empty string `""`. This disables Subresource Integrity (SRI) verification when `EngineLoader` fetches resources from a public CDN, violating the project's technical specification (TECHNICAL_SPECS.md section 1.3) and the repository's "security first" principle. If the CDN is compromised, a malicious script could be served to users without detection. Please provide a valid SRI hash for the `stockfish@16.1.0/src/stockfish.js` script in the `sources` configuration to ensure resource integrity.

<details>
<summary>References</summary>

1. The repository's style guide emphasizes a 'security first' principle, which is violated by disabling SRI. <sup>([link](https://github.com/hdkz-dev/multi-game-engines/blob/main/.gemini/styleguide.md))</sup>
2. The project's technical specification (TECHNICAL_SPECS.md section 1.3) mandates SRI for external resources to prevent tampering.
</details>
![security-medium](https://www.gstatic.com/codereviewagent/security-medium-priority.svg) ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The `createSearchCommand` method constructs a UCI command string by directly concatenating the `options.fen` property without any sanitization or validation. Since the UCI protocol uses newlines to separate commands, an attacker can inject arbitrary UCI commands (e.g., `quit`, `setoption`) by including newlines in the FEN string. This could lead to denial of service or unauthorized configuration changes of the engine.

Recommendation: Sanitize the `options.fen` string by removing or escaping newline characters before concatenation.

```suggestion
    const sanitizedFen = options.fen.replace(/[\r\n]/g, " ");
    let cmd = `position fen ${sanitizedFen}
go`;
```
![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

`mate` ã‚¹ã‚³ã‚¢ã‚’ `10000` ã¨ã„ã†ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’æ›ã‘ã¦è¡¨ç¾ã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯å¯èª­æ€§ã‚’ä½ä¸‹ã•ã›ã€å°†æ¥çš„ã«æ„å›³ãŒåˆ†ã‹ã‚Šã«ãããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã®ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’ã€æ„å›³ãŒæ˜ç¢ºã«ã‚ã‹ã‚‹åå‰ä»˜ãå®šæ•°ï¼ˆä¾‹: `MATE_SCORE_FLAG`ï¼‰ã¨ã—ã¦æŠ½å‡ºã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚³ãƒ¼ãƒ‰ã®è‡ªå·±æ–‡æ›¸åŒ–ãŒä¿ƒé€²ã•ã‚Œã€ä¿å®ˆæ€§ãŒå‘ä¸Šã—ã¾ã™ã€‚

```suggestion
          const MATE_SCORE_FLAG = 10000;
          info.score = scoreType === "mate" ? scoreValue * MATE_SCORE_FLAG : scoreValue;
```
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**å˜ä¸€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§è¤‡æ•°ã® pending expectation ãŒ resolve ã•ã‚Œã‚‹å¯èƒ½æ€§**

`for...of` ãƒ«ãƒ¼ãƒ—å†…ã§ `break` ãŒãªã„ãŸã‚ã€1ã¤ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¤‡æ•°ã® `expectMessage` ã® predicate ã«ãƒãƒƒãƒã—ãŸå ´åˆã€ã™ã¹ã¦ãŒåŒã˜ãƒ‡ãƒ¼ã‚¿ã§ resolve ã•ã‚Œã¾ã™ã€‚UCI ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚ˆã†ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ-ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ã€é€šå¸¸1ã¤ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯1ã¤ã®å¾…æ©Ÿã«ã®ã¿å¯¾å¿œã™ã‚‹ãŸã‚ã€æœ€åˆã®ãƒãƒƒãƒå¾Œã« `break` ã™ã¹ãã§ã™ã€‚

ã¾ãŸã€`predicate` ãŒä¾‹å¤–ã‚’ã‚¹ãƒ­ãƒ¼ã—ãŸå ´åˆã€`onmessage` ãƒãƒ³ãƒ‰ãƒ©å…¨ä½“ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã€æ®‹ã‚Šã® expectation ãŒè©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚

<details>
<summary>ğŸ› ä¿®æ­£æ¡ˆ</summary>

```diff
       for (const exp of this.pendingExpectations) {
-        if (exp.predicate(e.data)) {
-          this.pendingExpectations.delete(exp);
-          exp.resolve(e.data);
+        try {
+          if (exp.predicate(e.data)) {
+            this.pendingExpectations.delete(exp);
+            exp.resolve(e.data);
+            break;
+          }
+        } catch {
+          // predicate ã®ä¾‹å¤–ã¯ç„¡è¦–ã—ã¦æ¬¡ã® expectation ã‚’è©•ä¾¡
         }
```
</details>

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
      for (const exp of this.pendingExpectations) {
        try {
          if (exp.predicate(e.data)) {
            this.pendingExpectations.delete(exp);
            exp.resolve(e.data);
            break;
          }
        } catch {
          // predicate ã®ä¾‹å¤–ã¯ç„¡è¦–ã—ã¦æ¬¡ã® expectation ã‚’è©•ä¾¡
        }
      }
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/workers/WorkerCommunicator.ts` around lines 47 - 52, When
processing incoming messages in the onmessage handler, a single message can
currently resolve multiple pending expectations because the loop over
pendingExpectations doesn't stop after the first match; update the logic in
WorkerCommunicator.ts so that after finding and handling the first matching
expectation (the one where exp.predicate(e.data) is true), you delete it and
call exp.resolve(e.data) then break out of the loop to avoid resolving others;
additionally wrap the call to exp.predicate(e.data) in a try/catch so a thrown
exception from predicate doesn't crash the handler and instead skips that
expectation (optionally logging the error) â€” look for the pendingExpectations
collection, the expectMessage usage, and the exp.predicate/exp.resolve calls to
apply the change.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commit 688c607
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**`expectMessage` ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¨ `AbortSignal` ã®ã‚µãƒãƒ¼ãƒˆãŒãªã„**

`expectMessage` ã¯æ¡ä»¶ã«åˆè‡´ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå±Šã‹ãªã„é™ã‚Šæ°¸ä¹…ã«ãƒãƒ³ã‚°ã—ã¾ã™ã€‚ã‚¨ãƒ³ã‚¸ãƒ³ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã‚‚ `onerror` ãŒç™ºç«ã—ãªã„ã‚±ãƒ¼ã‚¹ï¼ˆä¾‹: Worker å†…ã§ç„¡é™ãƒ«ãƒ¼ãƒ—ï¼‰ã§ã¯ã€Promise ãŒè§£æ±ºã•ã‚Œã¾ã›ã‚“ã€‚

ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ `AbortSignal` ã®å„ªå…ˆæ¡ç”¨ãŒæ±‚ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚`options` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ `timeoutMs` ã‚„ `signal: AbortSignal` ã‚’å—ã‘ä»˜ã‘ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ã«ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ + AbortSignalï¼‰</summary>

```diff
- expectMessage<T>(predicate: (data: unknown) => boolean): Promise<T> {
-   return new Promise((resolve, reject) => {
-     this.pendingExpectations.add({ predicate, resolve, reject });
-   });
+ expectMessage<T>(
+   predicate: (data: unknown) => boolean,
+   options?: { timeoutMs?: number; signal?: AbortSignal }
+ ): Promise<T> {
+   const { timeoutMs, signal } = options ?? {};
+   return new Promise<T>((resolve, reject) => {
+     const entry = { predicate, resolve: resolve as (data: unknown) => void, reject };
+     this.pendingExpectations.add(entry);
+
+     if (timeoutMs !== undefined) {
+       setTimeout(() => {
+         if (this.pendingExpectations.delete(entry)) {
+           reject(new EngineError(EngineErrorCode.INTERNAL_ERROR, "expectMessage timed out."));
+         }
+       }, timeoutMs);
+     }
+
+     if (signal) {
+       signal.addEventListener("abort", () => {
+         if (this.pendingExpectations.delete(entry)) {
+           reject(new EngineError(EngineErrorCode.INTERNAL_ERROR, "expectMessage aborted."));
+         }
+       }, { once: true });
+     }
+   });
  }
```
</details>

As per coding guidelines, ã€Œæœ€æ–° Web æ¨™æº–ã®æ¡ç”¨å„ªå…ˆ: ... AbortSignal ... ã‚’æœ€å„ªå…ˆã§æ¡ç”¨ã™ã‚‹ã“ã¨ã€ã€‚

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/workers/WorkerCommunicator.ts` around lines 89 - 93, The
expectMessage method currently blocks indefinitely; modify expectMessage<T> to
accept an optional options object (e.g., { timeoutMs?: number, signal?:
AbortSignal }) and make it cancelable: create the Promise as before but register
a timeout timer when timeoutMs is provided and attach a signal.aborted listener
when signal is provided (treat AbortSignal as higher priority), ensure both the
timer and listener remove the pending expectation from this.pendingExpectations
and reject the Promise with an appropriate AbortError/TimeoutError; on
successful resolve (predicate match) clear the timer, remove the abort listener,
and remove the expectation; also guard against double-settling so resolve/reject
only once.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->

âœ… Addressed in commit 688c607
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**CI ã§ã¯ `pnpm install --frozen-lockfile` ã‚’ä½¿ç”¨ã™ã¹ãã§ã™ã€‚**

CI ç’°å¢ƒã§ `--frozen-lockfile` ã‚’ä»˜ã‘ãªã„ã¨ã€`pnpm-lock.yaml` ã¨ `package.json` ã®ä¸æ•´åˆæ™‚ã«ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒæš—é»™çš„ã«æ›´æ–°ã•ã‚Œã€å†ç¾ä¸å¯èƒ½ãªãƒ“ãƒ«ãƒ‰ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚


<details>
<summary>ğŸ”§ ä¿®æ­£æ¡ˆ</summary>

```diff
     - name: Install dependencies
-      run: pnpm install
+      run: pnpm install --frozen-lockfile
```
</details>

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In @.github/workflows/ci.yml around lines 43 - 44, CI step "Install
dependencies" currently runs "pnpm install" which can implicitly update
pnpm-lock.yaml; change the run command in that step (the Install dependencies
step) to use "pnpm install --frozen-lockfile" so the workflow fails if
package.json and pnpm-lock.yaml mismatch and prevents non-reproducible builds.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_ğŸ› ï¸ Refactor suggestion_ | _ğŸŸ  Major_

**`any` ã®ä½¿ç”¨ã¯ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«é•åã—ã¦ã„ã¾ã™**

`pendingReject` ã®å‹ã§ `any` ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ãŒã€ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã¯ `unknown` ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†æ±‚ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚`Promise` ã® reject ã¯ `unknown` ã§å‹ä»˜ã‘å¯èƒ½ã§ã™ã€‚

<details>
<summary>â™»ï¸ ä¿®æ­£æ¡ˆ</summary>

```diff
-  // eslint-disable-next-line `@typescript-eslint/no-explicit-any`
-  private pendingReject: ((reason?: any) => void) | null = null;
+  private pendingReject: ((reason?: unknown) => void) | null = null;
```
</details>

As per coding guidelines: ã€Œç¦æ­¢: `any` ã®ä½¿ç”¨ã€‚ä»£ã‚ã‚Šã« `unknown` ã¨å‹ã‚¬ãƒ¼ãƒ‰ã€ã¾ãŸã¯å¢ƒç•Œä»˜ãã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã€

<!-- suggestion_start -->

<details>
<summary>ğŸ“ Committable suggestion</summary>

> â€¼ï¸ **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
  private pendingReject: ((reason?: unknown) => void) | null = null;
```

</details>

<!-- suggestion_end -->

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 58 - 59, Replace
the explicit any on pendingReject with unknown to comply with the guideline:
change the type of the field pendingReject from ((reason?: any) => void) | null
to ((reason?: unknown) => void) | null (and remove the now-unnecessary
eslint-disable comment); if any callers inspect or handle the rejection reason,
add appropriate type guards or casts where they access the rejected value.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**å¤ã„ `infoController` ãŒ close ã•ã‚Œãšã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™**

æ–°ã—ã„æ¢ç´¢ã®é–‹å§‹å‰ã« `pendingReject` ã‚’å‘¼ã³å‡ºã—ã¦å‰å›ã® Promise ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¦ã„ã¾ã™ãŒã€`infoController` ã‚’ close ã—ã¦ã„ãªã„ãŸã‚ã€å‰å›ã® info ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® consumer ãŒãƒãƒ³ã‚°ã—ã¾ã™ã€‚

<details>
<summary>ğŸ› ä¿®æ­£æ¡ˆ</summary>

```diff
     if (this.pendingReject) {
       this.pendingReject(new EngineError(EngineErrorCode.INTERNAL_ERROR, "New search started before previous completed"));
       this.pendingReject = null;
       this.pendingResolve = null;
+      if (this.infoController) {
+        try { this.infoController.close(); } catch { /* already closed */ }
+        this.infoController = null;
+      }
     }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 151 - 156,
å‰å›ã®æ¤œç´¢ã‚’ä¸­æ–­ã™ã‚‹éš›ã« pendingReject/pendingResolve ã‚’å‘¼ã‚“ã§Promiseã‚’ç ´æ£„ã—ã¦ã„ã‚‹ãŒã€å¤ã„ infoController
ãŒ close ã•ã‚Œã¦ãŠã‚‰ãšå‰å›ã® info ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® consumer ãŒãƒãƒ³ã‚°ã™ã‚‹ãŸã‚ã€è©²å½“ç®‡æ‰€ï¼ˆä¾‹: startSearch / æ¤œç´¢é–‹å§‹ãƒ­ã‚¸ãƒƒã‚¯å†…ã®
this.pendingReject ãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã§ pendingReject ã‚’å‘¼ã¶å‰ã«ç¾åœ¨ã® this.infoController ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ç¢ºå®Ÿã«
close() ã‚’å‘¼ã³ã€å¿…è¦ãªã‚‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠã‚’è§£é™¤ã—ã¦ã‹ã‚‰ this.infoController = null ã«ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ã¦ãã ã•ã„ï¼ˆnull
è¨­å®šã¯ this.pendingReject/this.pendingResolve ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨æ•´åˆã•ã›ã‚‹ã“ã¨ï¼‰ã€‚
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

**`dispose()` ã§ `pendingResolve` ã¨ `infoController` ãŒã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã›ã‚“**

1. `pendingReject` ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã€`pendingResolve` ãŒ `null` ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°å‚ç…§ï¼‰ã€‚
2. ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæ¢ç´¢ä¸­ã« `dispose()` ãŒå‘¼ã°ã‚Œã‚‹ã¨ã€`infoController` ãŒ close ã•ã‚Œãšã€info ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® consumer ãŒãƒãƒ³ã‚°ã—ã¾ã™ã€‚

<details>
<summary>ğŸ› ä¿®æ­£æ¡ˆ</summary>

```diff
   async dispose(): Promise<void> {
     if (this.pendingReject) {
       this.pendingReject(new EngineError(EngineErrorCode.INTERNAL_ERROR, "Adapter disposed"));
       this.pendingReject = null;
+      this.pendingResolve = null;
+    }
+
+    if (this.infoController) {
+      try {
+        this.infoController.close();
+      } catch {
+        // already closed
+      }
+      this.infoController = null;
     }
+
     this.communicator?.terminate();
     this.communicator = null;
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/adapter-stockfish/src/stockfish.ts` around lines 205 - 221, The
dispose() method currently only calls pendingReject and leaves pendingResolve
dangling and doesn't close the info stream; update dispose() so after invoking
pendingReject(...) you also set pendingResolve = null and pendingReject = null
to avoid lingering references, and if an infoController exists call
infoController.close() (or equivalent shutdown method) and set infoController =
null so any consumers of the info stream are unblocked; keep the existing
communicator termination, blobUrl revocation (activeLoader.revoke(this.blobUrl))
and emitStatusChange("terminated")/clearListeners() behavior.
```

</details>

<!-- fingerprinting:phantom:poseidon:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_

**`progressListeners` ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã€å¯¾å¿œã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«è³¼èª­ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„**

Line 62 ã§ `progressListeners` ãŒå®šç¾©ã•ã‚Œã€`registerAdapter` å†… (Line 115-117) ã§ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®é€²æ—ã‚¤ãƒ™ãƒ³ãƒˆãŒè»¢é€ã•ã‚Œã¦ã„ã¾ã™ãŒã€`onGlobalStatusChange` ã‚„ `onGlobalTelemetry` ã®ã‚ˆã†ãªå…¬é–‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒ `progressListeners` ã«å¯¾ã—ã¦å­˜åœ¨ã—ã¾ã›ã‚“ã€‚é€²æ—ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ã™ã‚‹æ‰‹æ®µãŒãªãã€`progressListeners` ã¯å¸¸ã«ç©ºã®ã¾ã¾ã§ã™ã€‚

<details>
<summary>â™»ï¸ `onGlobalProgress` ãƒ¡ã‚½ãƒƒãƒ‰ã®è¿½åŠ ææ¡ˆ</summary>

```diff
+  /**
+   * å…¨ã‚¨ãƒ³ã‚¸ãƒ³ã®é€²æ—çŠ¶æ³ã‚’ä¸€æ‹¬ç›£è¦–ã—ã¾ã™ã€‚
+   * `@returns` è³¼èª­è§£é™¤é–¢æ•°
+   */
+  onGlobalProgress(callback: (id: string, progress: ILoadProgress) => void): () => void {
+    this.progressListeners.add(callback);
+    return () => this.progressListeners.delete(callback);
+  }
```

ã¾ãŸã€`IEngineBridge` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã‚‚ `onGlobalProgress` ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
</details>




Also applies to: 174-186

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineBridge.ts` around lines 60 - 63, The file
defines progressListeners (private progressListeners) and forwards adapter
progress events in registerAdapter but lacks a public way to subscribe; add a
new public method onGlobalProgress(callback: (id: string, progress:
ILoadProgress) => void): () => void to EngineBridge and declare it on the
IEngineBridge interface; implement it to add the callback to progressListeners
and return an unsubscribe function (mirroring
onGlobalStatusChange/onGlobalTelemetry behavior) so adapter-forwarded progress
events are actually received by consumers.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_

<details>
<summary>ğŸ§© Analysis chain</summary>

ğŸ Script executed:

```shell
# Find the EngineBridge.ts file and check the implementation
find . -name "EngineBridge.ts" -type f | head -5
```

Repository: hdkz-dev/multi-game-engines

Length of output: 113

---

ğŸ Script executed:

```shell
# Find the types.ts file in packages/core/src
find . -path "*/packages/core/src/types.ts" -type f
```

Repository: hdkz-dev/multi-game-engines

Length of output: 99

---

ğŸ Script executed:

```shell
# Read EngineBridge.ts around lines 174-177 and 183-186
cat -n ./packages/core/src/bridge/EngineBridge.ts | sed -n '170,190p'
```

Repository: hdkz-dev/multi-game-engines

Length of output: 770

---

ğŸ Script executed:

```shell
# Read types.ts around lines 452-454 to see the IEngineBridge interface
cat -n ./packages/core/src/types.ts | sed -n '450,460p'
```

Repository: hdkz-dev/multi-game-engines

Length of output: 490

---

ğŸ Script executed:

```shell
# Search for usages of onGlobalStatusChange and onGlobalTelemetry
rg -n 'onGlobalStatusChange|onGlobalTelemetry' --type=ts -A2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 1102

---

ğŸ Script executed:

```shell
# Check the line count of types.ts to understand context better
wc -l ./packages/core/src/types.ts
```

Repository: hdkz-dev/multi-game-engines

Length of output: 103

---

ğŸ Script executed:

```shell
# Check if EngineBridge implements IEngineBridge
cat -n ./packages/core/src/bridge/EngineBridge.ts | head -30
```

Repository: hdkz-dev/multi-game-engines

Length of output: 1032

---

ğŸ Script executed:

```shell
# Search for class declaration and implements clause
rg -n 'class EngineBridge' --type=ts -A5
```

Repository: hdkz-dev/multi-game-engines

Length of output: 510

---

ğŸ Script executed:

```shell
# Check for actual usages that call these methods
rg -n 'onGlobalStatusChange\(|onGlobalTelemetry\(' --type=ts -B2 -A2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 956

---

ğŸ Script executed:

```shell
# Also check if there are any test files that test this behavior
fd -e spec.ts -e test.ts | xargs rg -l 'onGlobalStatusChange|onGlobalTelemetry' 2>/dev/null
```

Repository: hdkz-dev/multi-game-engines

Length of output: 55

---

ğŸ Script executed:

```shell
# Check if IEngineBridge is exported and used elsewhere
rg -n 'IEngineBridge' --type=ts -B1 -A1 | head -50
```

Repository: hdkz-dev/multi-game-engines

Length of output: 1046

---

ğŸ Script executed:

```shell
# Look for any variable typed as IEngineBridge
rg -n ': IEngineBridge' --type=ts -B2 -A3
```

Repository: hdkz-dev/multi-game-engines

Length of output: 544

---

ğŸ Script executed:

```shell
# Check if EngineFacade calls onGlobalStatusChange or onGlobalTelemetry through the bridge
cat -n ./packages/core/src/bridge/EngineFacade.ts | head -100
```

Repository: hdkz-dev/multi-game-engines

Length of output: 3422

---

ğŸ Script executed:

```shell
# Search for calls to these methods in EngineFacade
rg -n 'this\.bridge\?.onGlobalStatusChange|this\.bridge\?.onGlobalTelemetry' --type=ts -B2 -A2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 53

---

ğŸ Script executed:

```shell
# Search more broadly for any calls to these methods
rg -n '\.onGlobalStatusChange|\.onGlobalTelemetry' --type=ts
```

Repository: hdkz-dev/multi-game-engines

Length of output: 53

---

ğŸ Script executed:

```shell
# Check the entire IEngineBridge interface definition
cat -n ./packages/core/src/types.ts | sed -n '419,455p'
```

Repository: hdkz-dev/multi-game-engines

Length of output: 1561

---

ğŸ Script executed:

```shell
# Let's double-check by looking at the complete context of both methods and how they're documented
cat -n ./packages/core/src/bridge/EngineBridge.ts | sed -n '168,190p'
```

Repository: hdkz-dev/multi-game-engines

Length of output: 789

---



</details>

**`onGlobalStatusChange` / `onGlobalTelemetry` ã®æˆ»ã‚Šå€¤å‹ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ä¸ä¸€è‡´**

å®Ÿè£…ã§ã¯ `() => void`ï¼ˆè³¼èª­è§£é™¤é–¢æ•°ï¼‰ã‚’è¿”ã—ã¦ã„ã¾ã™ãŒã€`IEngineBridge` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆ`packages/core/src/types.ts` lines 452-454ï¼‰ã§ã¯ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã¯ `void` ã¨å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚å‘¼ã³å‡ºã—å´ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã€è³¼èª­è§£é™¤é–¢æ•°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚

å®Ÿè£…ã®JSDocã‚³ãƒ¡ãƒ³ãƒˆï¼ˆ`@returns è³¼èª­è§£é™¤é–¢æ•°`ï¼‰ã®æ„å›³ã‚’åæ˜ ã—ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®æˆ»ã‚Šå€¤å‹ã‚’ `() => void` ã«æ›´æ–°ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineBridge.ts` around lines 174 - 177, The
implementation of onGlobalStatusChange and onGlobalTelemetry returns an
unsubscribe function (() => void) but IEngineBridge currently types these
methods as returning void; update the IEngineBridge interface (methods
onGlobalStatusChange and onGlobalTelemetry) to return () => void to match the
implementation and JSDoc so callers accessing the API via the interface can
receive the unsubscribe function.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ  Major_

<details>
<summary>ğŸ§© Analysis chain</summary>

ğŸ Script executed:

```shell
# EngineLoader.ts ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ ã‚’ç¢ºèª
find . -name "EngineLoader.ts" -type f
```

Repository: hdkz-dev/multi-game-engines

Length of output: 113

---

ğŸ Script executed:

```shell
# IEngineSourceConfig ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®šç¾©ã‚’æ¢ã™
rg -n "interface IEngineSourceConfig|type IEngineSourceConfig" --type ts -A 10
```

Repository: hdkz-dev/multi-game-engines

Length of output: 702

---

ğŸ Script executed:

```shell
# EngineLoader.ts ã®è¡Œ 39 ã¨ 65 ã®å‰å¾Œã‚’ç¢ºèª
rg -n "createObjectURL" --type ts -B 5 -A 2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 1981

---

ğŸ Script executed:

```shell
# IEngineSourceConfig ã®å®Œå…¨ãªå®šç¾©ã‚’å–å¾—
cat -n packages/core/src/types.ts | sed -n '154,180p'
```

Repository: hdkz-dev/multi-game-engines

Length of output: 852

---

ğŸ Script executed:

```shell
# loadResource ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Œå…¨ãªå®Ÿè£…ã‚’ç¢ºèª
cat -n packages/core/src/bridge/EngineLoader.ts | head -70
```

Repository: hdkz-dev/multi-game-engines

Length of output: 2779

---

ğŸ Script executed:

```shell
# è¿”ã•ã‚ŒãŸ blob URL ãŒã©ã“ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
rg -n "loadResource" --type ts -A 10 | grep -E "(loadResource|instantiate|WebAssembly)" -A 5
```

Repository: hdkz-dev/multi-game-engines

Length of output: 2521

---

ğŸ Script executed:

```shell
# WebAssembly ã®ä½¿ç”¨ç®‡æ‰€ã‚’ç¢ºèª
rg -n "instantiate|WebAssembly" --type ts -B 2 -A 2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 2894

---

ğŸ Script executed:

```shell
# ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å®Ÿè£…ã‚’ç¢ºèª - stockfish ã¨ä»–ã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼
fd -e ts "adapter" --type f | head -20
```

Repository: hdkz-dev/multi-game-engines

Length of output: 160

---

ğŸ Script executed:

```shell
# config.type ã«åŸºã¥ã„ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’ã©ã†æ‰±ã†ã‹ã‚’ç¢ºèª
rg -n 'config\.type|\.type.*case' --type ts -B 2 -A 2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 53

---

ğŸ Script executed:

```shell
# config.type ã®ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åºƒãæ¤œç´¢
rg -n "type" packages/core/src/bridge/EngineLoader.ts packages/adapter-stockfish/src/
```

Repository: hdkz-dev/multi-game-engines

Length of output: 745

---

ğŸ Script executed:

```shell
# WASM ã® instantiate ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œç´¢
rg -n "instantiate|fetch.*wasm" --type ts
```

Repository: hdkz-dev/multi-game-engines

Length of output: 53

---

ğŸ Script executed:

```shell
# BaseAdapter ã®å®Ÿè£…ã‚’ç¢ºèª
cat -n packages/core/src/adapters/BaseAdapter.ts | head -100
```

Repository: hdkz-dev/multi-game-engines

Length of output: 3473

---

ğŸ Script executed:

```shell
# ã™ã¹ã¦ã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å®Ÿè£…ã‚’ç¢ºèª
find packages -name "*.ts" -path "*/adapter-*/src/*" -type f | head -20
```

Repository: hdkz-dev/multi-game-engines

Length of output: 154

---

ğŸ Script executed:

```shell
# IEngineSourceConfig ã® sources ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä½¿ç”¨æ–¹æ³•ã‚’ç¢ºèª
rg -n "sources\." --type ts -B 2 -A 2
```

Repository: hdkz-dev/multi-game-engines

Length of output: 871

---

ğŸ Script executed:

```shell
# WebWorker ã§ BLOB URL ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèª
rg -n "new Worker|WorkerCommunicator" --type ts -B 3 -A 3
```

Repository: hdkz-dev/multi-game-engines

Length of output: 8238

---



</details>

**`config.type` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå®Œå…¨ã«ç„¡è¦–ã•ã‚Œã¦ãŠã‚Šã€MIME ã‚¿ã‚¤ãƒ—ã®æ±ºå®šãŒãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹**

`IEngineSourceConfig.type` ã«ã¯ `"wasm"`, `"worker-js"`, `"webgpu-compute"` ç­‰ 5 ã¤ã®å®Ÿè¡Œã‚¿ã‚¤ãƒ—ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ãŒã€`EngineLoader.loadResource()` ã§ã¯ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¸€åˆ‡ä½¿ç”¨ã›ãšã€å¸¸ã« `"application/javascript"` ã‚’ Blob ã® MIME ã‚¿ã‚¤ãƒ—ã¨ã—ã¦å›ºå®šã—ã¦ã„ã¾ã™ã€‚

ç¾åœ¨ã¯ stockfish ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ï¼ˆ`"worker-js"` ã‚¿ã‚¤ãƒ—ã®ã¿ï¼‰ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŸã‚å®Ÿå®³ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å°†æ¥ WASM ã‚„ WebGPU ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹éš›ã«ã¯ã€ãƒªã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦æ­£ã—ã„ MIME ã‚¿ã‚¤ãƒ—ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚`WebAssembly.instantiateStreaming()` ã‚„å„ç’°å¢ƒã® MIME ã‚¿ã‚¤ãƒ—æ¤œè¨¼ã§å•é¡ŒãŒç”Ÿã˜ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

<details>
<summary>â™»ï¸ config.type ã«åŸºã¥ã MIME ã‚¿ã‚¤ãƒ—ã®åˆ‡ã‚Šæ›¿ãˆå®Ÿè£…</summary>

```diff
+  private getMimeType(config: IEngineSourceConfig): string {
+    switch (config.type) {
+      case "wasm":
+        return "application/wasm";
+      case "webgpu-compute":
+        return "application/octet-stream";
+      default:
+        return "application/javascript";
+    }
+  }
+
   async loadResource(engineId: string, config: IEngineSourceConfig): Promise<string> {
     // ...
     if (cached) {
-      return URL.createObjectURL(new Blob([cached], { type: "application/javascript" }));
+      return URL.createObjectURL(new Blob([cached], { type: this.getMimeType(config) }));
     }
     // ...
-    return URL.createObjectURL(new Blob([data], { type: "application/javascript" }));
+    return URL.createObjectURL(new Blob([data], { type: this.getMimeType(config) }));
   }
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineLoader.ts` at line 39,
EngineLoader.loadResource() currently hardcodes the Blob MIME type to
"application/javascript" and ignores IEngineSourceConfig.type; change the logic
around the Blob creation (the line returning URL.createObjectURL(new
Blob([cached], { type: ... }))) to switch the MIME type based on config.type
(use "application/wasm" for "wasm", "application/javascript" for "worker-js" and
JS-based adapters like "webgpu-compute", and a safe fallback such as
"application/octet-stream" for unknown types) so that
WebAssembly.instantiateStreaming and other consumers receive the correct
Content-Type; ensure you reference IEngineSourceConfig.type when selecting the
type and keep the existing URL.createObjectURL/new Blob flow.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_

**`fetch` + `response.arrayBuffer()` ã§ SRI æ¤œè¨¼ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«æ³¨æ„**

`fetch` API ã® `integrity` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£å…¨ä½“ã®æ¶ˆè²»å¾Œã«æ¤œè¨¼ã•ã‚Œã¾ã™ã€‚`response.ok` ãƒã‚§ãƒƒã‚¯ï¼ˆLine 49ï¼‰ã¯ HTTP ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã¿ã‚’æ¤œæŸ»ã—ã€SRI ä¸ä¸€è‡´ã¯ `fetch` è‡ªä½“ãŒ reject ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“ãŒã€Line 57 ã® `response.arrayBuffer()` ãŒã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ãŸå ´åˆã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ‡æ–­ã‚„ SRI ä¸ä¸€è‡´ã®ä¾‹å¤–ãŒ `EngineError` ã«ãƒ©ãƒƒãƒ—ã•ã‚Œãšã«ä¼æ’­ã—ã¾ã™ã€‚

<details>
<summary>ğŸ›¡ï¸ fetch + arrayBuffer ã‚’ã¾ã¨ã‚ã¦ EngineError ã§ãƒ©ãƒƒãƒ—ã™ã‚‹ææ¡ˆ</summary>

```diff
     // 3. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰å–å¾— (SRI æ¤œè¨¼ä»˜ã)
     const options = SecurityAdvisor.getSafeFetchOptions(config.sri);
-    const response = await fetch(config.url, {
-      ...options,
-      signal: AbortSignal.timeout(30_000), // 30ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
-    });
-    
-    if (!response.ok) {
+    let data: ArrayBuffer;
+    try {
+      const response = await fetch(config.url, {
+        ...options,
+        signal: AbortSignal.timeout(30_000),
+      });
+      if (!response.ok) {
+        throw new EngineError(
+          EngineErrorCode.NETWORK_ERROR,
+          `Failed to download engine resource: ${config.url} (${response.status})`,
+          engineId
+        );
+      }
+      data = await response.arrayBuffer();
+    } catch (err) {
+      if (err instanceof EngineError) throw err;
       throw new EngineError(
         EngineErrorCode.NETWORK_ERROR,
-        `Failed to download engine resource: ${config.url} (${response.status})`,
-        engineId
+        `Failed to fetch engine resource: ${config.url}`,
+        engineId,
+        err
       );
     }
-
-    const data = await response.arrayBuffer();
```
</details>

<details>
<summary>ğŸ¤– Prompt for AI Agents</summary>

```
In `@packages/core/src/bridge/EngineLoader.ts` around lines 44 - 47, The fetch and
subsequent response.arrayBuffer() call in EngineLoader (where you call
fetch(config.url, {..., signal: AbortSignal.timeout(30_000)})) must be wrapped
in a single try/catch so any network errors, SRI mismatch rejections, or
arrayBuffer() failures are caught and rethrown as an EngineError; update the
logic around the fetch + response.arrayBuffer() sequence to catch all
exceptions, include the config.url and HTTP status/context in the EngineError
message, and preserve the original error as the cause so callers of EngineLoader
can handle failures uniformly.
```

</details>

<!-- fingerprinting:phantom:medusa:phoenix -->

<!-- This is an auto-generated comment by CodeRabbit -->
